
<html>
<head>

<style>
   BODY {background-color: white; 
         font-size: 10pt; font-family: verdana,helvetica;}
   A  {text-decoration: none;color: blue}
</style>
</head>
<body>

<a name='Linear Response'</a>
<H2>Linear Response</H2>


<p><b><a name='MagneticGaugeCorrection'></a>MagneticGaugeCorrection</b>
<br/><i>Section</i>: Linear Response
<br/><i>Type</i>: integer
<br/><i>Default</i>: gipaw
<br/><br> For magnetic linear response: how to handle gauge-invariance in the description
 of the coupling of electrons to the magnetic field.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  No correction.
</li>
<li><b>gipaw</b>:  GIPAW correction: C Pickard and F Mauri, <i>Phys. Rev. Lett.</i> <b>91</b>, 196401 (2003).
</li>
<li><b>icl</b>:  ICL correction: S Ismail-Beigi, EK Chang, and SG Louie, <i>Phys. Rev. Lett.</i> <b>87</b>, 087402 (2001).
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='ResponseMethod'></a>ResponseMethod</b>
<br/><i>Section</i>: Linear Response
<br/><i>Type</i>: integer
<br/><i>Default</i>: sternheimer
<br/><br> Some response properties can be calculated either via
 Sternheimer linear response or by using finite
 differences. You can use this variable to select how you want
 them to be calculated, it applies to <tt>em_resp</tt> and <tt>vib_modes</tt>
 calculation modes. By default, the Sternheimer linear-response
 technique is used.

<br/><i>Options</i>:
<ul>
<li><b>sternheimer</b>:  The linear response is obtained by solving a self-consistent
 Sternheimer equation for the variation of the orbitals. This
 is the recommended method.
</li>
<li><b>finite_differences</b>:  Properties are calculated as a finite-differences derivative of
 the energy obtained by several ground-state calculations. This
 method, slow and limited only to static response, is kept
 mainly because it is simple and useful for testing purposes.
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Linear Response::Casida'</a>
<H2>Linear Response::Casida</H2>


<p><b><a name='CasidaKohnShamStates'></a>CasidaKohnShamStates</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: string
<br/><i>Default</i>: all states
<br/><br> The calculation of the excitation spectrum of a system in the Casida frequency-domain
 formulation of linear-response time-dependent density functional theory (TDDFT)
 implies the use of a basis set of occupied/unoccupied Kohn-Sham orbitals. This
 basis set should, in principle, include all pairs formed by all occupied states,
 and an infinite number of unoccupied states. In practice, one has to truncate this
 basis set, selecting a number of occupied and unoccupied states that will form the
 pairs. These states are specified with this variable. If there are, say, 15 occupied
 states, and one sets this variable to the value "10-18", this means that occupied
 states from 10 to 15, and unoccupied states from 16 to 18 will be considered.
<br><br>
 This variable is a string in list form, <i>i.e.</i> expressions such as "1,2-5,8-15" are
 valid. You should include a non-zero number of unoccupied states and a non-zero number
 of occupied states.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaMomentumTransfer'></a>CasidaMomentumTransfer</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: block
<br/><br> Momentum-transfer vector for the calculation of the dynamic structure
 factor. When this variable is set, the transition rates are determined
 using an exponential operator instead of the normal dipole one.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaQuadratureOrder'></a>CasidaQuadratureOrder</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: integer
<br/><i>Default</i>: 5
<br/><br> Directionally averaged dynamic structure factor is calculated by
 averaging over the results from a set of <i>q</i>-vectors. The vectors
 are generated using Gauss-Legendre quadrature scheme [see <i>e.g.</i>
 K. Atkinson, <i>J. Austral. Math. Soc.</i> <b>23</b>, 332 (1982)], and this
 variable determines the order of the scheme.

</p><hr width='30%' align='left'/>


<p><b><a name='CasidaTransitionDensities'></a>CasidaTransitionDensities</b>
<br/><i>Section</i>: Linear Response::Casida
<br/><i>Type</i>: string
<br/><i>Default</i>: write none
<br/><br> Specifies which transition densities are to be calculated and written down. The
 transition density for the many-body state <i>n</i> will be written to a file called
 <tt>casida/rho0n</tt>.
<br><br>
 This variable is a string in list form, <i>i.e.</i> expressions such as "1,2-5,8-15" are
 valid.

</p><hr width='30%' align='left'/>

<a name='Linear Response::KdotP'</a>
<H2>Linear Response::KdotP</H2>


<p><b><a name='KdotPCalculateEffectiveMasses'></a>KdotPCalculateEffectiveMasses</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If true, uses <tt>kdotp</tt> perturbations of ground-state wavefunctions
 to calculate effective masses.

</p><hr width='30%' align='left'/>


<p><b><a name='KdotPEta'></a>KdotPEta</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> Imaginary frequency added to Sternheimer equation which may improve convergence.
 Not recommended.

</p><hr width='30%' align='left'/>


<p><b><a name='KdotPOccupiedSolutionMethod'></a>KdotPOccupiedSolutionMethod</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: integer
<br/><i>Default</i>: sternheimer
<br/><br> Method of calculating the contribution of the projection of the
  linear-response wavefunctions in the occupied subspace.

<br/><i>Options</i>:
<ul>
<li><b>sternheimer_eqn</b>:  The Sternheimer equation is solved including the occupied subspace,
 to get the full linear-response wavefunctions.
</li>
<li><b>sum_over_states</b>:  The Sternheimer equation is solved only in the unoccupied subspace,
 and a sum-over-states perturbation-theory expression is used to
 evaluate the contributions in the occupied subspace.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='KdotPUseNonLocalPseudopotential'></a>KdotPUseNonLocalPseudopotential</b>
<br/><i>Section</i>: Linear Response::KdotP
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> For testing purposes, set to false to ignore the term -i[r,V] in
 the k.p perturbation, which is due to non-local pseudopotentials.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Polarizabilities'</a>
<H2>Linear Response::Polarizabilities</H2>


<p><b><a name='BornChargeSumRuleCorrection'></a>BornChargeSumRuleCorrection</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Enforce the acoustic sum rule by distributing the excess sum of Born charges equally among the atoms.
 Sum rule: sum(iatom) Z*(iatom,idir,idir2) = Z_tot delta(idir1, idir2).
 Violation of the sum rule may be caused by inadequate spacing, box size, or <i>k</i>-point sampling.

</p><hr width='30%' align='left'/>


<p><b><a name='EMCalcBornCharges'></a>EMCalcBornCharges</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Calculate linear-response Born effective charges from electric perturbation (experimental).

</p><hr width='30%' align='left'/>


<p><b><a name='EMCalcRotatoryResponse'></a>EMCalcRotatoryResponse</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Calculate circular-dichroism spectrum from electric perturbation,
 and write to file <tt>rotatory_strength</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMEta'></a>EMEta</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.0
<br/><br> The imaginary part of the frequency, effectively a Lorentzian broadening
 for peaks in the spectrum. It can help convergence of the SCF cycle for the
 Sternheimer equation when on a resonance, and it can be used as a positive
 infinitesimal to get the imaginary parts of response functions at poles.
 In units of energy. Cannot be negative.

</p><hr width='30%' align='left'/>


<p><b><a name='EMForceNoKdotP'></a>EMForceNoKdotP</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> If the system is periodic, by default wavefunctions from a previous <tt>kdotp</tt> run will
 be read, to be used in the formulas for the polarizability and
 hyperpolarizability in the quantum theory of polarization. For testing purposes,
 you can set this variable to true to disregard the <tt>kdotp</tt> run, and use the formulas
 for the finite system. This variable has no effect for a finite system.

</p><hr width='30%' align='left'/>


<p><b><a name='EMFreqs'></a>EMFreqs</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: block
<br/><br> This block defines for which frequencies the polarizabilities
 will be calculated. If it is not present, the static (omega = 0) response
 is calculated.
<br><br>
 Each row of the block indicates a sequence of frequency values, the
 first column is an integer that indicates the number of steps, the
 second number is the initial frequency, and the third number the final
 frequency. If the first number is one, then only the initial value is
 considered. The block can have any number of rows. Consider the next example:
<br><br>
 <tt>%EMFreqs
 <br>31 | 0.0 | 1.0
 <br> 1 | 0.32
 <br>%</tt>
<br><br>

</p><hr width='30%' align='left'/>


<p><b><a name='EMFreqsSort'></a>EMFreqsSort</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> If true, the frequencies specified by the <tt>EMFreqs</tt> block are sorted, so that
 they are calculated in increasing order. Can be set to false to use the order as stated,
 in case this makes better use of available restart information.

</p><hr width='30%' align='left'/>


<p><b><a name='EMHyperpol'></a>EMHyperpol</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: block
<br/><br> This block describes the multiples of the frequency used for
 the dynamic hyperpolarizability. The results are written to the
 file <tt>beta</tt> in the directory for the first multiple.

</p><hr width='30%' align='left'/>


<p><b><a name='EMOccupiedResponse'></a>EMOccupiedResponse</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Solve for full response without projector into unoccupied subspace.
 Not possible if there are partial occupations.

</p><hr width='30%' align='left'/>


<p><b><a name='EMPerturbationType'></a>EMPerturbationType</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: integer
<br/><i>Default</i>: electric
<br/><br> Which perturbation to consider for electromagnetic linear response.

<br/><i>Options</i>:
<ul>
<li><b>none</b>:  Zero perturbation, for use in testing.
</li>
<li><b>electric</b>:  Electric perturbation used to calculate electric polarizabilities
 and hyperpolarizabilities.
</li>
<li><b>magnetic</b>:  Magnetic perturbation used to calculate magnetic susceptibilities.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='EMWavefunctionsFromScratch'></a>EMWavefunctionsFromScratch</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Do not use saved linear-response wavefunctions from a previous run as starting guess.
 Instead initialize to zero as in <tt>FromScratch</tt>, but restart densities will still
 be used. Restart wavefunctions from a very different frequency can hinder convergence.

</p><hr width='30%' align='left'/>


<p><b><a name='vdWNPoints'></a>vdWNPoints</b>
<br/><i>Section</i>: Linear Response::Polarizabilities
<br/><i>Type</i>: integer
<br/><br> How many points to use in the Gauss-Legendre integration to obtain the
 van der Waals coefficients. The default is 6.

</p><hr width='30%' align='left'/>

<a name='Linear Response::SCF in LR calculations'</a>
<H2>Linear Response::SCF in LR calculations</H2>


<p><b><a name='LRConvAbsDens'></a>LRConvAbsDens</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-5
<br/><br> The tolerance in the variation of the density, to determine if
 the SCF for linear response is converged.

</p><hr width='30%' align='left'/>


<p><b><a name='LRMaximumIter'></a>LRMaximumIter</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: integer
<br/><i>Default</i>: 200
<br/><br> The maximum number of SCF iterations to calculate response.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolAdaptiveFactor'></a>LRTolAdaptiveFactor</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.1
<br/><br> This factor controls how much the tolerance is decreased
 during the self-consistency process. Smaller values mean that
 tolerance is decreased faster.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolIterWindow'></a>LRTolIterWindow</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: float
<br/><i>Default</i>: 10
<br/><br> Number of iterations necessary to reach the final tolerance

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolScheme'></a>LRTolScheme</b>
<br/><i>Section</i>: Linear Response::SCF in LR calculations
<br/><i>Type</i>: integer
<br/><i>Default</i>: tol_adaptive
<br/><br> The scheme used to adjust the tolerance of the solver during
 the SCF iteration. For <tt>kdotp</tt> and magnetic <tt>em_resp</tt> modes, or
 whenever <tt>HamiltonianVariation = V_ext_only</tt>, the
 scheme is set to fixed, and this variable is ignored.

<br/><i>Options</i>:
<ul>
<li><b>tol_fixed</b>:  The solver tolerance is fixed for all the iterations; this
 improves convergence but increases the computational cost
</li>
<li><b>tol_adaptive</b>:  The tolerance is increased according to the level of
 convergence of the SCF.
</li>
<li><b>tol_linear</b>:  The tolerance decreases linearly for the first <tt>LRTolIterWindow</tt> iterations.
</li>
<li><b>tol_exp</b>:  The tolerance decreases exponentially for the first <tt>LRTolIterWindow</tt> iterations.
</li>
</ul>
</p><hr width='30%' align='left'/>

<a name='Linear Response::Solver'</a>
<H2>Linear Response::Solver</H2>


<p><b><a name='LRTolFinalTol'></a>LRTolFinalTol</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-6
<br/><br> This is the tolerance to determine that the linear solver has converged.

</p><hr width='30%' align='left'/>


<p><b><a name='LRTolInitTol'></a>LRTolInitTol</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: float
<br/><i>Default</i>: 1e-2
<br/><br> This is the tolerance to determine that the linear solver has converged,
 for the first SCF iteration. Ignored if <tt>LRTolScheme = fixed</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='LinearSolver'></a>LinearSolver</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: integer
<br/><i>Default</i>: qmr_symmetric
<br/><br> Method for solving linear equations, which occur for Sternheimer linear
 response and OEP. The solvers vary in speed, reliability (ability to
 converge), and domain of applicability. QMR solvers are most reliable.

<br/><i>Options</i>:
<ul>
<li><b>bicgstab</b>:  Biconjugate gradients stabilized. Slower than <tt>cg</tt>, but more reliable.
 General matrices.
</li>
<li><b>cg</b>:  Conjugate gradients. Fast but unreliable. Hermitian matrices only
 (no eta in Sternheimer).
</li>
<li><b>multigrid</b>:  Multigrid solver, currently only Gauss-Jacobi (experimental).
 Slow, but fairly reliable. General matrices.
</li>
<li><b>qmr_symmetric</b>:  Quasi-minimal residual solver, for (complex) symmetric matrices. [Real symmetric
 is equivalent to Hermitian.] Slightly slower than <tt>bicgstab</tt> but more reliable.
 For Sternheimer, must be real wavefunctions, but can have eta.
</li>
<li><b>qmr_symmetrized</b>:  Quasi-minimal residual solver, using the symmetrized form A^T A x = A^T y instead of
 A x = y. Reliable but very slow. General matrices.
</li>
<li><b>qmr_dotp</b>:  Quasi-minimal residual solver, for Hermitian matrices, using the
 symmetric algorithm with conjugated dot product (experimental). Slightly slower than <tt>bicgstab</tt>
 but more reliable. Can always be used in Sternheimer.
</li>
<li><b>qmr_general</b>:  Quasi-minimal residual solver, for general matrices, using the
 most general form of the algorithm. Slow and unreliable.
</li>
<li><b>sos</b>:  Sum over states: the Sternheimer equation is solved by using
 the explicit solution in terms of the ground-state
 wavefunctions. You need unoccupied states to use this method.
 Unlike the other methods, may not give the correct answer.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='LinearSolverMaxIter'></a>LinearSolverMaxIter</b>
<br/><i>Section</i>: Linear Response::Solver
<br/><i>Type</i>: integer
<br/><i>Default</i>: 1000
<br/><br> Maximum number of iterations the linear solver does, even if
 convergence is not achieved.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Static Polarization'</a>
<H2>Linear Response::Static Polarization</H2>


<p><b><a name='EMCalcDiagonalField'></a>EMCalcDiagonalField</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Calculate <i>yz</i>-field for beta_<i>xyz</i> hyperpolarizability, which is sometimes harder to converge.
 Only applies if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMStartDensityIsZeroField'></a>EMStartDensityIsZeroField</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Use the charge density from the zero-field calculation as the starting density for
 SCF calculations with applied fields. For small fields, this will be fastest.
 If there is trouble converging with larger fields, set to false,
 to initialize the calculation for each field from scratch, as specified by the LCAO variables.
 Only applies if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMStaticElectricField'></a>EMStaticElectricField</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.01 a.u.
<br/><br> Magnitude of the static electric field used to calculate the static polarizability,
 if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMVerbose'></a>EMVerbose</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: false
<br/><br> Write full SCF output.
 Only applies if <tt>ResponseMethod = finite_differences</tt>.

</p><hr width='30%' align='left'/>


<p><b><a name='EMWriteRestartDensities'></a>EMWriteRestartDensities</b>
<br/><i>Section</i>: Linear Response::Static Polarization
<br/><i>Type</i>: logical
<br/><i>Default</i>: true
<br/><br> Write density after each calculation for restart, rather than just the resulting electronic dipole moment.
 Only applies if <tt>ResponseMethod = finite_differences</tt>. Restarting from calculations at smaller
 fields can be helpful if there are convergence problems.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Sternheimer'</a>
<H2>Linear Response::Sternheimer</H2>


<p><b><a name='HamiltonianVariation'></a>HamiltonianVariation</b>
<br/><i>Section</i>: Linear Response::Sternheimer
<br/><i>Type</i>: integer
<br/><i>Default</i>: hartree+fxc
<br/><br> The terms to be considered in the variation of the
 Hamiltonian. V_ext is always considered. The default is to include
 also the exchange-correlation and Hartree terms, which fully
 takes into account local fields.
 Just <tt>hartree</tt> gives you the random-phase approximation (RPA).
 If you want to choose the exchange-correlation kernel, use the variable
 <tt>XCKernel</tt>. For <tt>kdotp</tt> and magnetic <tt>em_resp</tt> modes,
 or if <tt>TheoryLevel = independent_particles</tt>,
 the value <tt>V_ext_only</tt> is used and this variable is ignored.

<br/><i>Options</i>:
<ul>
<li><b>V_ext_only</b>:  Neither Hartree nor XC potentials included.
</li>
<li><b>hartree</b>:  The variation of the Hartree potential only.
</li>
<li><b>fxc</b>:  The exchange-correlation kernel (the variation of the
 exchange-correlation potential) only.
</li>
</ul>
</p><hr width='30%' align='left'/>


<p><b><a name='Preorthogonalization'></a>Preorthogonalization</b>
<br/><i>Section</i>: Linear Response::Sternheimer
<br/><i>Type</i>: logical
<br/><br> Whether initial linear-response wavefunctions should be orthogonalized
 or not against the occupied states, at the start of each SCF cycle.
 Default is true only if <tt>SmearingFunction = semiconducting</tt>,
 or if the <tt>Occupations</tt> block specifies all full or empty states.

</p><hr width='30%' align='left'/>

<a name='Linear Response::Vibrational Modes'</a>
<H2>Linear Response::Vibrational Modes</H2>


<p><b><a name='Displacement'></a>Displacement</b>
<br/><i>Section</i>: Linear Response::Vibrational Modes
<br/><i>Type</i>: float
<br/><i>Default</i>: 0.01 a.u.
<br/><br> When calculating phonon properties by finite differences (<tt>CalculationMode = vib_modes,
 ResponseMethod = finite_differences </tt>),
 <tt>Displacement</tt> controls how much the atoms are to be moved in order to calculate the
 dynamical matrix.

</p><hr width='30%' align='left'/>

</body>
</html>