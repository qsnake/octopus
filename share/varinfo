Variable LiquidDensity
Type float
Section Utilities::oct-liquid
Description
 This  variable  specifies the density of the liquid to be generated. It has
 to be given in units of grammes per cubic centimeters gr/cm^3. 
END

Variable LiquidNumberOfMolecules
Type integer
Section Utilities::oct-liquid
Description
 This  variable  specifies  the number of molecules that will be included in
 the liquid. 
END

Variable LiquidMoleculeScale
Type float
Section Utilities::oct-liquid
Description
 This  value  specifies how much the original molecule will be scaled in the
 liquid. The default is 1.0. 
END

Variable CasidaSpectrumBroadening
Type float
Default 0.005
Section Utilities::oct-casida_spectrum
Description
 Width of the Lorentzian used to broaden the excitations. 
END

Variable CasidaSpectrumEnergyStep
Type float
Default 0.001
Section Utilities::oct-casida_spectrum
Description
 Sampling rate for the spectrum. 
END

Variable CasidaSpectrumMinEnergy
Type float
Default 0.0
Section Utilities::oct-casida_spectrum
Description
 The broadening is done for energies greater than CasidaSpectrumMinEnergy. 
END

Variable CasidaSpectrumMaxEnergy
Type float
Default 1.0
Section Utilities::oct-casida_spectrum
Description
 The broadening is done for energies smaller than CasidaSpectrumMaxEnergy. 
END

Variable AnimationSampling
Type integer
Default 100
Section Utilities::oct-xyz-anim
Description
 Sampling rate of the animation. The animation will be constructed using the
 iteration numbers that are multiples of AnimationSampling. 
END

Variable LCAOAlternative
Type logical
Default false
Section SCF::LCAO
Description
 If  this  variable  is set, the LCAO procedure will use an alternative (and
 experimental)  implementation.  It is faster for large systems and parallel
 in states. 
END

Variable LCAODimension
Type integer
Default 0
Section SCF::LCAO
Description
 Before starting the SCF cycle, an initial LCAO calculation can be performed
 in  order  to  obtain  reasonable  initial  guesses  for  spin-orbitals and
 densities.  For  this  purpose,  the  code  calculates  a  number of atomic
 orbitals -- this number depends on the given species. The default dimension
 for  the  LCAO  basis set will be the sum of all these numbers, unless this
 dimension is larger than twice the number of required orbitals for the full
 calculation. 

 This  dimension however can be changed by making use of this variable. Note
 that  LCAODimension cannot be smaller than the number of orbitals needed in
 the full calculation -- if 
 LCAODimension  is  smaller,  it  will  be  silently  increased to meet this
 requirement. In the same way, if LCAODimension is larger than the available
 number  of  atomic  orbitals,  it  will  be reduced. If you want to use the
 largest possible number, set 
 LCAODimension to a negative number. 
END

Variable LCAOKeepOrbitals
Type logical
Default yes
Section SCF::LCAO
Description
 If  set to yes (the default) Octopus keeps atomic orbitals in memory during
 the LCAO procedure. If set to no, the orbitals are generated each time that
 they are needed, increasing computational time but saving memory. 

 When  set  to  yes,  Octopus  prints  the amount of memory per node that is
 required to store the orbitals. 

END

Variable LCAOExtraOrbitals
Type logical
Default false
Section SCF::LCAO
Description
 (experimental)  If this variable is set to yes, the LCAO procedure will add
 an  extra  set of numerical orbitals (by using the derivative of the radial
 part of the original orbitals). 
END

Variable LCAODiagTol
Type float
Default 1e-10
Section SCF::LCAO
Description
 The  tolerance for the diagonalization of the LCAO Hamiltonian. The default
 is 1e-10. 
END

Variable LCAOStart
Type integer
Section SCF
Description
 Before  starting a SCF calculation, Octopus can perform a LCAO calculation.
 These can provide Octopus with a good set of initial wavefunctions and with
 a  new  guess  for  the density. (Up to the current version, only a minimal
 basis  set  is  used.)  The  default  is  lcao_full  unless all species are
 user-defined, in which case the default is lcao_none. 
Option lcao_none 0
 Do  not perform a LCAO calculation before the SCF cycle. Instead use random
 wavefunctions. 
Option lcao_states 2
 Do  a  LCAO  calculation  before  the  SCF  cycle  and  use  the  resulting
 wavefunctions  as initial wavefunctions without changing the guess density.
 This  will speed up the convergence of the eigensolver during the first SCF
 iterations. 
Option lcao_full 3
 Do  a  LCAO calculation before the SCF cycle and use the LCAO wavefunctions
 to build a new guess density and a new KS potential. Using the LCAO density
 as  a  new  guess density may improve the convergence, but can also slow it
 down or yield wrong results (especially for spin-polarized calculations). 
END

Variable MaximumIter
Type integer
Default 200
Section SCF::Convergence
Description
 Maximum  number  of  SCF iterations. The code will stop even if convergence
 has not been achieved. -1 means unlimited. 
END

Variable MaximumIterBerry
Type integer
Default 10
Section SCF::Convergence
Description
 Maximum  number  of  iterations  for  the  Berry potential, within each SCF
 iteration.  Only  applies if a StaticElectricField is applied in a periodic
 direction.  The  code  will  move  on  to  the  next  SCF iteration even if
 convergence has not been achieved. -1 means unlimited. 
END

Variable ConvAbsDens
Type float
Default 0.0
Section SCF::Convergence
Description
 Absolute convergence of the density: 

 \epsilon  =  \int  {\rm  d}^3r  \vert  \rho^{out}(\bf r) -\rho^{inp}(\bf r)
 \vert. 

 A zero value (the default) means do not use this criterion. 
END

Variable ConvRelDens
Type float
Default 1e-5
Section SCF::Convergence
Description
 Relative convergence of the density: 

 \epsilon = {1\over N} ConvAbsDens. 

 _N_  is the total number of electrons in the problem. A zero value means do
 not use this criterion. 
END

Variable ConvAbsEv
Type float
Default 0.0
Section SCF::Convergence
Description
 Absolute convergence of the sum of the eigenvalues: 

  \epsilon  =  \vert  \sum_{j=1}^{N_{occ}}  \epsilon_j^{out}  -
 \sum_{j=1}^{N_{occ}} \epsilon_j^{inp} \vert  

 A zero value (the default) means do not use this criterion. 
END

Variable ConvRelEv
Type float
Default 0.0
Section SCF::Convergence
Description
 Relative convergence of the sum of the eigenvalues: 

 \epsilon  =  {1  \over  \vert  \sum_{j=1}^{N_{occ}} \epsilon_j^{out} \vert}
 \vert  \sum_{j=1}^{N_{occ}}  \epsilon_j^{out}-  \sum_{j=1}^{N_{occ}}
 \epsilon_j^{inp} \vert <\math> 

A zero value (the default) means do not use this criterion.
END

Variable ConvForce
Type float
Default 0.0
Section SCF::Convergence
Description
 Absolute  convergence  of the forces: maximum variation of any component of
 the  ionic  forces  in  consecutive  iterations. A zero value (the default)
 means do not use this criterion. 
END

Variable MixField
Type integer
Default density
Section SCF::Mixing
Description
 Selects  what should be mixed during the SCF cycle. Note that currently the
 exact-exchange  part of hybrid functionals is not mixed at all, which would
 require  wavefunction-mixing,  not  yet  implemented.  This  may  lead  to
 instabilities  in  the  SCF  cycle,  so  starting  from a converged LDA/GGA
 calculation  is  recommended for hybrid functionals. The default depends on
 the TheoryLevel and the exchange-correlation potential used. 
Option none 0
 No mixing is done. This is the default for independent particles. 
Option potential 1
 The  Kohn-Sham  potential  is  mixed.  This  is the default for OEP or MGGA
 calculations, or if StaticElectricField is applied in a periodic direction.
 
Option density 2
 Mix  the  density.  This  is the default for other cases, including LDA/GGA
 calculations. 
END

Variable SCFinLCAO
Type logical
Default no
Section SCF
Description
 Performs  the  SCF  cycle  with  the  calculation  restricted  to  the LCAO
 subspace.  This  may be useful for systems with convergence problems (first
 do a calculation within the LCAO subspace, then restart from that point for
 an unrestricted calculation). 
END

Variable SCFCalculateForces
Type logical
Section SCF
Description
 This variable controls whether the forces on the ions are calculated at the
 end  of  a self-consistent iteration. The default is yes, unless the system
 only has user-defined species. 
END

Variable SCFCalculateDipole
Type logical
Section SCF
Description
 This  variable  controls  whether  the dipole is calculated at the end of a
 self-consistent  iteration.  For  finite  systems  the  default is yes. For
 periodic  systems  the  default  is  no,  unless an electric field is being
 applied  in  a  periodic  direction.  The  single-point  Berry`s  phase
 approximation is used for periodic directions. 
END

Variable LocalMagneticMomentsSphereRadius
Type float
Section Output
Description
 The  local magnetic moments are calculated by integrating the magnetization
 density  in  spheres  centered around each atom. This variable controls the
 radius of the spheres. The default is half the minimum distance between two
 atoms in the input coordinates. 
END

Variable ProfilingMode
Default no
Type integer
Section Execution::Optimization
Description
 Use this variable to run Octopus in profiling mode. In this mode 
 Octopus  records the time spent in certain areas of the code and the number
 of  times  this  code  is  executed.  These  numbers  are  written  in
 ./profiling.NNN/profiling.nnn  with  nnn  being  the  node  number  (000 in
 serial)  and  NNN  the number of processors. This is mainly for development
 purposes. Note, however, that 
 Octopus should be compiled with --disable-debug to do proper profiling. 
Option no 0
 No profiling information is generated. 
Option prof_time 1
 Profile the time spent in defined profiling regions. 
Option prof_memory 2
 As well as the time, memory usage is reported. 
Option prof_memory_full 4
 As well as the time, full memory usage is reported. 
END

Variable ProfilingAllNodes
Default no
Type integer
Section Execution::Optimization
Description
 This  variable  controls whether all nodes print the time profiling output.
 If  set  to  no, the default, only the root node will write the profile. If
 set to yes all nodes will print it. 
END

Variable MemoryLimit
Default -1
Type integer
Section Execution::Optimization
Description
 If positive, Octopus will stop if more memory than MemoryLimit is requested
 (in kb). Note that this variable only works when 
 ProfilingMode = prof_memory(_full). 
END

Variable ExperimentalFeatures
Type logical
Default no
Section Execution::Debug
Description
 If  true,  allows the use of certain parts of the code that are still under
 development  and  are  not suitable for production runs. This should not be
 used unless you know what you are doing. 
END

Variable DebugLevel
Type integer
Default 0
Section Execution::Debug
Description
 This  variable decides whether or not to enter debug mode. If it is greater
 than 0, different amounts of additional information are written to standard
 output and additional assertion checks are performed. 
Option 0
 (default) Octopus does not enter debug mode. 
Option 1
 Moderate amount of debug output; assertion checks enabled. 
Option 2
 The  code  prints a stack trace as it enters end exits subroutines. This is
 useful  for developers and you should include this output when submitting a
 bug report. 
Option 99
 The  debug  output is additionally written to files in the debug directory.
 For each node (when running in parallel) there is a file called 
 debug_trace.&lt;rank&gt;. Writing these files slows down the code by a huge
 factor  and  it  is usually only necessary for parallel runs. In the serial
 case all the information can be obtained from standard out. 
END

Variable DisableOpenCL
Type logical
Default yes
Section Execution::OpenCL
Description
 If  Octopus was compiled with OpenCL support, it will try to initialize and
 use  an OpenCL device. By setting this variable to yes you tell Octopus not
 to use OpenCL. 
END

Variable OpenCLPlatform
Type integer
Default 0
Section Execution::OpenCL
Description
 This variable selects the OpenCL platform that Octopus will use. Platform 0
 is used by default. 
END

Variable OpenCLDevice
Type integer
Default 0
Section Execution::OpenCL
Description
 This  variable selects the OpenCL device that Octopus will use. Device 0 is
 used by default. 
END

Variable Dimensions
Type integer
Section System
Default 3
Description
 Octopus  can  run  in  1, 2 or 3 dimensions, depending on the value of this
 variable. Note that not all input variables may be available in all cases. 
END

Variable Units
Type integer
Default atomic
Section Execution::Units
Description
 This variable selects the units that Octopus use for input and output. 

 Atomic  units  seem  to be the preferred system in the atomic and molecular
 physics community. Internally, the code works in atomic units. However, for
 input  or output, some people like to use a system based in eV for energies
 and \AA for length. The default is atomic units. 

 Normally  time  units  are  derived  from energy and length units, so it is
 measured in \hbar/Hartree or 
 \hbar/electronvolt.  Alternatively you can tell Octopus to use femtoseconds
 as  the time unit by adding the value femtoseconds (Note that no other unit
 will be based on femtoseconds). So for example you can use: 

 Units = femtoseconds 

 or 

 Units = ev_angstrom + femtoseconds 

 You  can  use  different  unit  systems for input and output by setting the
 UnitsInput and UnitsOutput. 

 Warning  1: All files read on input will also be treated using these units,
 including XYZ geometry files. 

 Warning  2: Some values are treated in their most common units, for example
 atomic  masses  (a.m.u.),  electron  effective  masses  (electron  mass),
 vibrational  frequencies  (cm<sup>-1</sup>)  or  temperatures (Kelvin). The
 unit of charge is always the electronic charge _e_. 

Option atomic        0
 Atomic units. 
Option ev_angstrom   1
 Electronvolts  for  energy, Angstroms for length, the rest of the units are
 derived from these and hbar=1. 
Option femtoseconds  2
 (Experimental)  If  you  add  this value to the other options, Octopus will
 treat time in femtoseconds units. 
END

Variable UnitsInput
Type integer
Default atomic
Section Execution::Units
Description
 Same as Units, but only refers to input values. 
END

Variable UnitsOutput
Type integer
Default atomic
Section Execution::Units
Description
 Same as Units, but only refers to output values. 
END

Variable ParallelizationGroupRanks
Type block
Section Execution::Parallelization
Description
 Specifies  the size of the groups used for the parallelization. For example
 (n_d, n_s, n_k) means we have 
 _n_p*n_s*n_k_ processors and that the _k_-points should be divided in _n_k_
 groups,  the  states  in _n_s_ groups, and each state in _n_d_ domains. You
 can  pass  the  value  fill  to one field: it will be replaced by the value
 required to complete the number of processors in the run. 
Option fill -1
 Replaced by the value required to complete the number of processors. 
END

Variable ParallelizationNumberSlaves
Type integer
Section Execution::Parallelization
Description
 Slaves are nodes used for task parallelization. The number of such nodes is
 given  by  this variable multiplied by the number of domains used in domain
 parallelization. The default is 0. 
END

Variable ParallelizationStrategy
Type flag
Section Execution::Parallelization
Description
 Specifies  what  kind  of  parallelization strategy Octopus should use. The
 values  can  be  combined:  for  example,  par_domains + par_states means a
 combined  parallelization  in  domains  and  states. Default: par_domains +
 par_states for CalculationMode = td , 
 par_domains  +  par_other  for  CalculationMode  =  casida  ,  otherwise
 par_domains. 
Option serial 0
 Octopus will run in serial. 
Option par_domains 1
 Octopus will run parallel in domains. 
Option par_states  2
 Octopus will run parallel in states. 
Option par_kpoints 4
 Octopus will run parallel in _k_-points/spin. 
Option par_other   8
 Run-mode-dependent.  For  example,  in  casida, it means parallelization in
 _e-h_ pairs. 
END

Variable stdout
Type string
Default "-"
Section Execution::IO
Description
 The  standard output by default goes to, well, to standard output. This can
 be changed by setting this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead. 
END

Variable stderr
Type string
Default "-"
Section Execution::IO
Description
 The standard error by default goes to, well, to standard error. This can be
 changed  by  setting  this variable: if you give it a name (other than "-")
 the output stream is printed in that file instead. 
END

Variable WorkDir
Type string
Default "."
Section Execution::IO
Description
 By default, all files are written and read from the working directory, 
 _i.e._  the directory from which the executable was launched. This behavior
 can  be changed by setting this variable: if you give it a name (other than
 ".") the files are written and read in that directory. 
END

Variable FlushMessages
Type logical
Default no
Section Execution::IO
Description
 In  addition to writing to stdout and stderr, the code messages may also be
 flushed  to messages.stdout and messages.stderr, if this variable is set to
 yes. 
END

Variable TmpDir
Default "restart/"
Type string
Section Execution::IO
Description
 The  name  of the directory where Octopus stores binary information such as
 the wavefunctions. 
END

Variable MPIDebugHook
Type logical
Default no
Section Execution::Debug
Description
 When  debugging  the  code  in parallel it is usually difficult to find the
 origin  of race conditions that appear in MPI communications. This variable
 introduces a facility to control separate MPI processes. If set to yes, all
 nodes  will  start  up,  but  will get trapped in an endless loop. In every
 cycle of the loop each node is sleeping for one second and is then checking
 if  a  file with the name node_hook.xxx (where xxx denotes the node number)
 exists.  A  given  node  can  only  be  released  from  the  loop  if  the
 corresponding  file  is  created. This allows to selectively run, _e.g._, a
 compute  node  first followed by the master node. Or, by reversing the file
 creation  of  the node hooks, to run the master first followed by a compute
 node. 
END

Variable DeltaEFMM
Type float
Default 0.0001
Section Hamiltonian::Poisson
Description
 Parameter  for  absolute  or relative convergence of FMM. Sets energy error
 bound.  Strong  inhomogeneous  systems  may  violate  the  error bound. For
 inhomogeneous  systems  we  have  an  error-controlled  sequential  version
 available (from Ivo Kabadshow). 
END

Variable AbsRelFMM
Type integer
Default 2
Section Hamiltonian::Poisson
Description
 Sets  type  of  error  bound. 0 = 10^-3 relative error. 1 = absolute deltaE
 error. The error (deltaE) is a fraction of the unity of energy 2 = relative
 deltaE error. The error is the given ratio (deltaE) of the total energy > -
 Could  you explain me what is the difference between considering relative >
 or absolute error in the calculations, and why you choose your default as >
 deltaE=E-3, absrel=relative? The default is just standard error, which fits
 most  situations.  It means, your energy has three significant digits. Lets
 say  the energy of your system is 1000.0, then the FMM will compute results
 with  a precision of +-1. So the result will be energy=999 ... 1001. If you
 change  deltaE to 10^-6 it would be something in between energy=999.999 ...
 1000.001  If  you do know the magnitude of your energy and set absrel to an
 absolute  error  the  situation is different. Setting deltaE to 10^-2 means
 you  will  an  energy=999.99..1000.01 which corresponds to 10^5 as relative
 error.  Which  one  you  choose  is  up to you. Since you want to calculate
 periodic  systems,  you may experience very precise results even if you set
 deltaE  very low. It is a side effect from the periodicity (totalcharge=0),
 but  should not bother you at all. You get this kind of extra precision for
 free. 
END

Variable DipoleCorrection
Type integer
Default 0
Section Hamiltonian::Poisson
Description
 Extrinsic/Intrinsic  potential.  If  you want to compare to classical Ewald
 use 0 or 1. 
Option 0
 FMM decides whether correction should be applied. 
Option 1
 Apply dipole correction. 
Option -1
 Disables dipole correction. 
END

Variable PoissonSolverNodes
Type integer
Section Hamiltonian::Poisson
Default 0
Description
 How  many  nodes  to  use  to solve the Poisson equation. A value of 0, the
 default, implies that all available nodes are used. 
END

Variable ParallelizationPoissonAllNodes
Type logical
Default true
Section Execution::Parallelization
Description
 When  running in parallel, this variable selects whether the Poisson solver
 should  divide  the  work  among  all  nodes  or  only  among  the
 parallelization-in-domains groups. 
END

Variable PoissonSolver
Type integer
Section Hamiltonian::Poisson
Description
 Defines which method to use to solve the Poisson equation. Defaults: 
  1D: fft if not periodic, fft_nocut if periodic. 
  2D:  fft if not periodic, fft_cyl if periodic in 1D, fft_nocut if periodic
 in 2D. 
  3D:  cg_corrected if curvilinear, isf if not periodic, fft_cyl if periodic
 in 1D, 
 fft_pla if periodic in 2D, fft_nocut if periodic in 3D. 
Option FMM -4
 Fast multipole method. 
Option direct3D -3
 Direct evaluation of the Hartree potential (in 3D). 
Option direct2D -2
 Direct evaluation of the Hartree potential (in 2D). 
Option direct1D -1
 Direct evaluation of the Hartree potential (in 1D). 
Option fft 0
 FFTs using spherical cutoff (in 2D or 3D; uses FFTW). 
Option fft_cyl 1
 FFTs using cylindrical cutoff (in 3D; uses FFTW). 
Option fft_pla 2
 FFTs using planar cutoff (in 3D; uses FFTW). 
Option fft_nocut 3
 FFTs without using a cutoff (in 3D; uses FFTW). 
Option fft_corrected 4
 FFTs + corrections. 
Option cg 5
 Conjugate gradients. 
Option cg_corrected 6
 Corrected conjugate gradients. 
Option multigrid 7
 Multigrid method. 
Option isf 8
 Interpolating Scaling Functions Poisson solver. 
Option sete 9
 (Experimental) SETE solver. 
END

Variable PoissonSolverMGPresmoothingSteps
Type integer
Default 1
Section Hamiltonian::Poisson::Multigrid
Description
 Number  of  Gauss-Seidel  smoothing steps before coarse-level correction in
 the multigrid Poisson solver. 
END

Variable PoissonSolverMGPostsmoothingSteps
Type integer
Default 4
Section Hamiltonian::Poisson::Multigrid
Description
 Number of Gauss-Seidel smoothing steps after coarse-level correction in the
 multigrid Poisson solver. 
END

Variable PoissonSolverMGMaxCycles
Type integer
Default 60
Section Hamiltonian::Poisson::Multigrid
Description
 Maximum number of multigrid cycles that are performed if convergence is not
 achieved. 
END

Variable PoissonSolverMGRestrictionMethod
Type integer
Default fullweight
Section Hamiltonian::Poisson::Multigrid
Description
 Method used from fine-to-coarse grid transfer. 
Option injection 1
 Injection 
Option fullweight 2
 Fullweight restriction 
END

Variable PoissonSolverMGRelaxationMethod
Type integer
Section Hamiltonian::Poisson::Multigrid
Description
 Method  used  to solve the linear system approximately in each grid for the
 multigrid  procedure that solves Poisson equation. Default is gauss_seidel,
 unless  curvilinear  coordinates  are  used,  in  which case the default is
 gauss_jacobi. 
Option gauss_seidel 1
 Gauss-Seidel. 
Option gauss_jacobi 2
 Gauss-Jacobi. 
Option gauss_jacobi2 3
 Alternative implementation of Gauss-Jacobi. 
END

Variable PoissonSolverMGRelaxationFactor
Type float
Section Hamiltonian::Poisson::Multigrid
Description
 Relaxation factor of the relaxation operator used for the multigrid method.
 This  is  mainly  for  debugging,  since  overrelaxation does not help in a
 multigrid  scheme.  The  default is 1.0, except 0.6666 for the gauss_jacobi
 method. 
END

Variable PoissonSolverMaxMultipole
Type integer
Section Hamiltonian::Poisson
Description
 Order  of  the  multipolar expansion for boundary corrections. Default is 4
 for PoissonSolver = cg_corrected and multigrid and 2 for fft_corrected. 
END

Variable PoissonSolverMaxIter
Type integer
Section Hamiltonian::Poisson
Default 400
Description
 The maximum number of iterations for conjugate-gradient Poisson solvers. 
END

Variable PoissonSolverThreshold
Type float
Section Hamiltonian::Poisson
Default 1e-5
Description
 The tolerance for the Poisson solution, used by the cg and 
 multigrid solvers. 
END

Variable SpeciesProjectorSphereThreshold
Type float
Default 0.001
Section System::Species
Description
 The  pseudopotentials  may  be  composed  of  a  local  part,  and a linear
 combination  of  nonlocal  operators.  These  nonlocal  projectors  have
 "projector"  form,  |_v_&gt;&lt;_v_|  (or,  more  generally  speaking,
 |_u_&gt;&lt;_v_|). These projectors are localized in real space -- that is,
 the function _v_ has a finite support around the nucleus. This region where
 the  projectors  are localized should be small or else the computation time
 required to operate with them will be very large. 

 In  practice, this localization is fixed by requiring the definition of the
 projectors  to be contained in a sphere of a certain radius. This radius is
 computed by making sure that the absolute value of the projector functions,
 at  points  outside  the localization sphere, is below a certain threshold.
 This threshold is set by SpeciesProjectorSphereThreshold. 
END

Variable Species
Type block
Section System::Species
Description
 A  species  is  by  definition  either  an "ion" (nucleus + core electrons)
 described through a pseudopotential, or a user-defined model potential. 

 Note that some common pseudopotentials are distributed with the code in the
 directory OCTOPUS-HOME/share/PP/. To use these pseudopotentials you are not
 required  to  define  them explicitly in the Species block, as defaults are
 provided  by  the  program  (you  can override these defaults in any case).
 Additional pseudopotentials can be downloaded from the 
 <a
 href='http://www.tddft.org/programs/octopus/wiki/index.php/Pseudopotentials'>
 octopus homepage</a>. 

 The  format  of this block is the following: The first field is the name of
 the  species, followed by the atomic mass (in atomic mass units). The third
 field  defines  the type of species (the valid options are detailed below).
 Each  type  also needs some parameters given in the remaining fields of the
 row. 

 In 3D, _e.g._ 

 %Species 
   'O' | 15.9994 | spec_ps_psf | 8 | 1 | 1 
   'H' | 1.0079 | spec_ps_hgh | 1 | 0 | 0 
   'jlm' | 23.2 | spec_jelli | 8 | 5.0 
   'rho' | 17.0 | spec_charge_density | 6 | "exp(-r/a)" 
   'pnt' | 32.3 | spec_point | 2.0 
   'udf' | 0.0 | spec_user_defined | 8 | "1/2*r^2" 
   'H_all' | 1.0079 | spec_full_delta | 1 
   'H_all' | 1.0079 | spec_full_gaussian | 1 
 % 

 Additionally,  all  the pseudopotential types (PSF, HGH, FHI, UPF) can take
 two  extra  fields:  default  spacing, and default radius (used for minimum
 simulation box if the radius is not specified). 
Option spec_user_defined 123
 Species  with user-defined potential. In this case, the fourth field is the
 valence  charge  and  the  fifth  field  is  a  string  with a mathematical
 expression that defines the potential (you can use any of the _x_, _y_, _z_
 or _r_ variables). 
Option spec_point  2
 Point charge: the fourth field is the value of the charge. 
Option spec_jelli  3
 Jellium  sphere:  the extra parameters are the charge of the jellium sphere
 (an equal value of valence charge is assumed) and the radius of the sphere.
 
Option spec_ps_psf  100
 Troullier  Martins  pseudopotential  in  SIESTA format: the pseudopotential
 will  be  read  from a .psf file, either in the working directory or in the
 OCTOPUS-HOME/share/octopus/PP/PSF directory. Columns 4, 5, 6 are the atomic
 number, the maximum 
 _l_-component  of  the  pseudopotential to consider in the calculation, and
 the _l_-component to consider as local. 
Option spec_ps_hgh  101
 Hartwigsen-Goedecker-Hutter pseudopotentials: column 4 is the atomic number
 and  columns 5 and 6 are irrelevant, since they are not necessary to define
 the HGH pseudopotential. 
Option spec_ps_cpi  102
 Fritz-Haber  pseudopotential:  the pseudopotential will be read from a .cpi
 file,  either  in the working directory or in the OCTOPUS-HOME/share/PP/CPI
 directory. Columns 4, 5, 6 are the atomic number, the maximum 
 _l_-component  of  the  pseudopotential to consider in the calculation, and
 the _l_-component to consider as local. 
Option spec_ps_fhi  103
 Fritz-Haber  pseudopotential  (ABINIT  format): the pseudopotential will be
 read  from  a  .fhi  file,  either  in  the  working  directory  or  in the
 OCTOPUS-HOME/share/PP/FHI directory. Columns 4, 5, 6 are the atomic number,
 the maximum 
 _l_-component  of  the  pseudopotential to consider in the calculation, and
 the  _l_-component  to  consider  as  local.  Note  that  you  can  use the
 pseudopotentials from ABINIT homepage. 
Option spec_ps_upf  104
 UPF  format:  the  pseudopotential will be read from a .UPF file, either in
 the working directory or in the OCTOPUS-HOME/share/PP/UPF directory. Column
 4  is  the  atomic  number.  Columns  5  and  6 are ignored, as the maximum
 _l_-component of the pseudopotential to consider in the calculation and the
 _l_-component  to  consider  as  local are indicated in the pseudopotential
 file are cannot be changed. 
Option spec_full_delta   127
 Full  atomic potential represented by a delta charge distribution. The atom
 will be displaced to the nearest grid point. Column 4 is the atomic number.
 
Option spec_full_gaussian   124
 A  full-potential  atom  is  defined by a Gaussian accumulation of positive
 charge (distorted if curvilinear coordinates are used), in the form: 

  q(r)  =  z  *  \beta  * exp[ - (\vec{r}-\vec{r0})**2 / (sqrt(2) * \delta *
 \sigma) ] 
  

 \beta  is chosen in order to maintain proper normalization (the integral of
 q should sum up to 
 z). \delta is the grid spacing (the grid spacing in the first dimension, to
 be precise). 
 \vec{r0} is calculated in such a way that the the first moment of q(r)/z is
 equal to the atomic position. For a precise description, see N. A. Modine, 
 _Phys. Rev. B_ *55*, 10289 (1997). 

 Column 4 is the atomic number and column 5 is 
 sigma, the width of the gaussian that should be small, but you may run into
 numerical difficulties if it is too small (0.25 by default). 
Option spec_charge_density 125
 The  potential is created by a distribution of charge. The extra parameters
 are  the  valence  charge  of the species, and an expression for the charge
 distribution. 
Option species_from_file  126
 The potential is read from a file, whose name is given in column 5. 
END

Variable MGGAimplementation
Type integer
Default mgga_gea
Section Hamiltonian::XC
Description
 Decides how to implement the meta-GGAs (NOT WORKING). 
Option mgga_dphi 1
 Use  for  v_xc  the  derivative  of  the  energy functional with respect to
 \phi^*(r).  This is the approach used in most quantum-chemistry (and other)
 programs. 
Option mgga_gea 2
 Use gradient expansion (GEA) of the kinetic-energy density. 
Option mgga_oep 3
 Use  the OEP equation to obtain the XC potential. This is the "correct" way
 to do it within DFT. 
END

Variable XCKernel
Type integer
Default lda_x+lda_c_pz_mod
Section Hamiltonian::XC
Description
 Defines  the  exchange-correlation  kernel.  Only LDA kernels are available
 currently. 
Option xc_functional -1
 The same functional defined by XCFunctional. 
END

Variable JFunctional
Type integer
Default lca_omc
Section Hamiltonian::XC
Description
 Defines the current functional for current-density functional theory. 
Option none 0
Option lca_omc 301
 Orestes, Marcasso & Capelle. 
Option lca_lch 302
 Lee, Colwell & Handy. 
END

Variable Interaction1D
Type integer
Default interaction_soft_coulomb
Section Hamiltonian::XC
Description
 When  running  in  1D,  one  has  to  soften  the Coulomb interaction. This
 softening is not unique, and several possibilities exist in the literature.
 
Option interaction_exp_screened 0
 Exponentially  screened  Coulomb  interaction.  See,  _e.g._,  M  Casula, S
 Sorella, and G Senatore, _Phys. Rev. B_ *74*, 245427 (2006). 
Option interaction_soft_coulomb 1
 Soft  Coulomb  interaction  of  the form 1/sqrt(x^2 + alpha^2). This is the
 default. 
END

Variable Interaction1DScreening
Type float
Default 1.0
Section Hamiltonian::XC
Description
 Defines the screening parameter, alpha, of the softened Coulomb interaction
 when running in 1D. The default value is 1.0. 
END

Variable XCFunctional
Type integer
Section Hamiltonian::XC
Description
 Defines  the exchange and correlation functional to be used; they should be
 specified as a sum of a correlation term and an exchange term. Defaults: 
  1D: lda_x_1d + lda_c_1d_csc 
  2D: lda_x_2d + lda_c_2d_amgb 
  3D: lda_x + lda_c_pz_mod 
Option lda_x               1
 Exchange 
Option lda_c_wigner               2000
 Wigner parametrization 
Option lda_c_rpa               3000
 Random Phase Approximation 
Option lda_c_hl               4000
 Hedin & Lundqvist 
Option lda_c_gl               5000
 Gunnarson & Lundqvist 
Option lda_c_xalpha               6000
 Slater Xalpha 
Option lda_c_vwn               7000
 Vosko, Wilk, & Nussair 
Option lda_c_vwn_rpa               8000
 Vosko, Wilk, & Nussair (RPA) 
Option lda_c_pz               9000
 Perdew & Zunger 
Option lda_c_pz_mod               10000
 Perdew & Zunger (Modified) 
Option lda_c_ob_pz               11000
 Ortiz & Ballone (PZ) 
Option lda_c_pw               12000
 Perdew & Wang 
Option lda_c_pw_mod               13000
 Perdew & Wang (Modified) 
Option lda_c_ob_pw               14000
 Ortiz & Ballone (PW) 
Option lda_c_2d_amgb               15000
 Attacalite et al 
Option lda_c_2d_prm               16000
 Pittalis, Rasanen & Marques correlation in 2D 
Option lda_c_vbh               17000
 von Barth & Hedin 
Option lda_c_1d_csc               18000
 Casula, Sorella, and Senatore 1D correlation 
Option lda_x_2d               19
 Exchange in 2D 
Option lda_xc_teter93               20000
 Teter 93 parametrization 
Option lda_x_1d               21
 Exchange in 1D 
Option lda_c_ml1               22000
 Modified LSD (version 1) of Proynov and Salahub 
Option lda_c_ml2               23000
 Modified LSD (version 2) of Proynov and Salahub 
Option lda_c_gombas               24000
 Gombas parametrization 
Option lda_k_tf               50
 Thomas-Fermi kinetic energy functional 
Option lda_k_lp               51
 Lee and Parr Gaussian ansatz 
Option gga_x_pbe               101
 Perdew, Burke & Ernzerhof exchange 
Option gga_x_pbe_r               102
 Perdew, Burke & Ernzerhof exchange (revised) 
Option gga_x_b86               103
 Becke 86 Xalfa,beta,gamma 
Option gga_x_herman               104
 Herman et al original GGA 
Option gga_x_b86_mgc               105
 Becke 86 Xalfa,beta,gamma (with mod. grad. correction) 
Option gga_x_b88               106
 Becke 88 
Option gga_x_g96               107
 Gill 96 
Option gga_x_pw86               108
 Perdew & Wang 86 
Option gga_x_pw91               109
 Perdew & Wang 91 
Option gga_x_optx               110
 Handy & Cohen OPTX 01 
Option gga_x_dk87_r1               111
 dePristo & Kress 87 (version R1) 
Option gga_x_dk87_r2               112
 dePristo & Kress 87 (version R2) 
Option gga_x_lg93               113
 Lacks & Gordon 93 
Option gga_x_ft97_a               114
 Filatov & Thiel 97 (version A) 
Option gga_x_ft97_b               115
 Filatov & Thiel 97 (version B) 
Option gga_x_pbe_sol               116
 Perdew, Burke & Ernzerhof exchange (solids) 
Option gga_x_rpbe               117
 Hammer, Hansen & Norskov (PBE-like) 
Option gga_x_wc               118
 Wu & Cohen 
Option gga_x_mpw91               119
 Modified form of PW91 by Adamo & Barone 
Option gga_x_am05               120
 Armiento & Mattsson 05 exchange 
Option gga_x_pbea               121
 Madsen (PBE-like) 
Option gga_x_mpbe               122
 Adamo & Barone modification to PBE 
Option gga_x_xpbe               123
 xPBE reparametrization by Xu & Goddard 
Option gga_x_2d_b86_mgc               124
 Becke 86 MGC for 2D systems 
Option gga_x_bayesian               125
 Bayesian best fit for the enhancement factor 
Option gga_x_pbe_jsjr               126
 JSJR reparametrization by Pedroza, Silva & Capelle 
Option gga_x_2d_b88               127
 Becke 88 in 2D 
Option gga_x_2d_b86               128
 Becke 86 Xalfa,beta,gamma 
Option gga_x_2d_pbe               129
 Perdew, Burke & Ernzerhof exchange in 2D 
Option gga_c_pbe               130000
 Perdew, Burke & Ernzerhof correlation 
Option gga_c_lyp               131000
 Lee, Yang & Parr 
Option gga_c_p86               132000
 Perdew 86 
Option gga_c_pbe_sol               133000
 Perdew, Burke & Ernzerhof correlation SOL 
Option gga_c_pw91               134000
 Perdew & Wang 91 
Option gga_c_am05               135000
 Armiento & Mattsson 05 correlation 
Option gga_c_xpbe               136000
 xPBE reparametrization by Xu & Goddard 
Option gga_c_lm               137000
 Langreth and Mehl correlation 
Option gga_c_pbe_jrgx               138000
 JRGX reparametrization by Pedroza, Silva & Capelle 
Option gga_x_optb88_vdw               139
 Becke 88 reoptimized to be used with vdW functional of Dion et al 
Option gga_x_pbek1_vdw               140
 PBE reparametrization for vdW 
Option gga_x_optpbe_vdw               141
 PBE reparametrization for vdW 
Option gga_x_rge2               142
 Regularized PBE 
Option gga_c_rge2               143000
 Regularized PBE 
Option gga_x_rpw86               144
 refitted Perdew & Wang 86 
Option gga_x_kt1               145
 Keal and Tozer version 1 
Option gga_xc_kt2               146000
 Keal and Tozer version 2 
Option gga_c_wl               147000
 Wilson & Levy 
Option gga_c_wi               148000
 Wilson & Ivanov 
Option gga_x_lb               160
 van Leeuwen & Baerends 
Option gga_xc_hcth_93               161000
 HCTH functional fitted to 93 molecules 
Option gga_xc_hcth_120               162000
 HCTH functional fitted to 120 molecules 
Option gga_xc_hcth_147               163000
 HCTH functional fitted to 147 molecules 
Option gga_xc_hcth_407               164000
 HCTH functional fitted to 147 molecules 
Option gga_xc_edf1               165000
 Empirical functionals from Adamson, Gill, and Pople 
Option gga_xc_xlyp               166000
 XLYP functional 
Option gga_xc_b97               167000
 Becke 97 
Option gga_xc_b97_1               168000
 Becke 97-1 
Option gga_xc_b97_2               169000
 Becke 97-2 
Option gga_xc_b97_d               170000
 Grimme functional to be used with C6 vdW term 
Option gga_xc_b97_k               171000
 Boese-Martin for Kinetics 
Option gga_xc_b97_3               172000
 Becke 97-3 
Option gga_xc_pbe1w               173000
 Functionals fitted for water 
Option gga_xc_mpwlyp1w               174000
 Functionals fitted for water 
Option gga_xc_pbelyp1w               175000
 Functionals fitted for water 
Option gga_xc_sb98_1a               176000
 Schmider-Becke 98 parameterization 1a 
Option gga_xc_sb98_1b               177000
 Schmider-Becke 98 parameterization 1b 
Option gga_xc_sb98_1c               178000
 Schmider-Becke 98 parameterization 1c 
Option gga_xc_sb98_2a               179000
 Schmider-Becke 98 parameterization 2a 
Option gga_xc_sb98_2b               180000
 Schmider-Becke 98 parameterization 2b 
Option gga_xc_sb98_2c               181000
 Schmider-Becke 98 parameterization 2c 
Option gga_x_lbm               182
 van Leeuwen & Baerends modified 
Option gga_k_vw               500
 von Weiszaecker correction to Thomas-Fermi 
Option gga_k_ge2               501
 Second-order gradient expansion (l = 1/9) 
Option gga_k_golden               502
 TF-lambda-vW form by Golden (l = 13/45) 
Option gga_k_yt65               503
 TF-lambda-vW form by Yonei and Tomishima (l = 1/5) 
Option gga_k_baltin               504
 TF-lambda-vW form by Baltin (l = 5/9) 
Option gga_k_lieb               505
 TF-lambda-vW form by Lieb (l = 0.185909191) 
Option gga_k_absr1               506
 gamma-TFvW form by Acharya et al [g = 1 - 1.412/N^(1/3)] 
Option gga_k_absr2               507
 gamma-TFvW form by Acharya et al [g = 1 - 1.332/N^(1/3)] 
Option gga_k_gr               508
 gamma-TFvW form by Gázquez and Robles 
Option gga_k_ludena               509
 gamma-TFvW form by Ludeña 
Option gga_k_gp85               510
 gamma-TFvW form by Ghosh and Parr 
Option gga_k_pearson               511
 Pearson 
Option gga_k_ol1               512
 Ou-Yang and Levy v.1 
Option gga_k_ol2               513
 Ou-Yang and Levy v.2 
Option gga_k_fr_b88               514
 Fuentealba & Reyes (B88 version) 
Option gga_k_fr_pw86               515
 Fuentealba & Reyes (PW86 version) 
Option hyb_gga_xc_b3pw91               401000
 The original hybrid proposed by Becke 
Option hyb_gga_xc_b3lyp               402000
 The (in)famous B3LYP 
Option hyb_gga_xc_b3p86               403000
 Perdew 86 hybrid similar to B3PW91 
Option hyb_gga_xc_o3lyp               404000
 hybrid using the optx functional 
Option hyb_gga_xc_mpw1k               405000
 mixture of mPW91 and PW91 optimized for kinetics 
Option hyb_gga_xc_pbeh               406000
 aka PBE0 or PBE1PBE 
Option hyb_gga_xc_b97               407000
 Becke 97 
Option hyb_gga_xc_b97_1               408000
 Becke 97-1 
Option hyb_gga_xc_b97_2               410000
 Becke 97-2 
Option hyb_gga_xc_x3lyp               411000
 maybe the best hybrid 
Option hyb_gga_xc_b1wc               412000
 Becke 1-parameter mixture of WC and PBE 
Option hyb_gga_xc_b97_k               413000
 Boese-Martin for Kinetics 
Option hyb_gga_xc_b97_3               414000
 Becke 97-3 
Option hyb_gga_xc_mpw3pw               415000
 mixture with the mPW functional 
Option hyb_gga_xc_b1lyp               416000
 Becke 1-parameter mixture of B88 and LYP 
Option hyb_gga_xc_b1pw91               417000
 Becke 1-parameter mixture of B88 and PW91 
Option hyb_gga_xc_mpw1pw               418000
 Becke 1-parameter mixture of mPW91 and PW91 
Option hyb_gga_xc_mpw3lyp               419000
 mixture of mPW and LYP 
Option hyb_gga_xc_sb98_1a               420000
 Schmider-Becke 98 parameterization 1a 
Option hyb_gga_xc_sb98_1b               421000
 Schmider-Becke 98 parameterization 1b 
Option hyb_gga_xc_sb98_1c               422000
 Schmider-Becke 98 parameterization 1c 
Option hyb_gga_xc_sb98_2a               423000
 Schmider-Becke 98 parameterization 2a 
Option hyb_gga_xc_sb98_2b               424000
 Schmider-Becke 98 parameterization 2b 
Option hyb_gga_xc_sb98_2c               425000
 Schmider-Becke 98 parameterization 2c 
Option mgga_x_lta               201
 Local tau approximation of Ernzerhof & Scuseria 
Option mgga_x_tpss               202
 Perdew, Tao, Staroverov & Scuseria exchange 
Option mgga_x_m06l               203
 Zhao, Truhlar exchange 
Option mgga_x_gvt4               204
 GVT4 from Van Voorhis and Scuseria (exchange part) 
Option mgga_x_tau_hcth               205
 tau-HCTH from Boese and Handy 
Option mgga_x_br89               206
 Becke-Roussel 89 
Option mgga_x_bj06               207
 Becke & Johnson correction to Becke-Roussel 89 
Option mgga_x_tb09               208
 Tran & Blaha correction to Becke & Johnson 
Option mgga_x_rpp09               209
 Rasanen, Pittalis, and Proetto correction to Becke & Johnson 
Option mgga_x_2d_prhg07               210
 Pittalis, Rasanen, Helbig, Gross Exchange Functional 
Option mgga_x_2d_prhg07_prp10               211
 PRGH07 with PRP10 correction 
Option mgga_c_tpss               231000
 Perdew, Tao, Staroverov & Scuseria correlation 
Option mgga_c_vsxc               232000
 VSxc from Van Voorhis and Scuseria (correlation part) 
Option lca_omc               301
 Orestes, Marcasso & Capelle 
Option lca_lch               302
 Lee, Colwell & Handy 
Option oep_x                    901
 OEP: Exact exchange 
Option none                       0
 Exchange and correlation set to zero. 
END

Variable EMFreqs
Type block
Section Linear Response::Polarizabilities
Description
 This  block  defines  for  which  frequencies  the polarizabilities will be
 calculated.  If  it  is  not  present,  the  static (omega = 0) response is
 calculated. 

 Each  row  of the block indicates a sequence of frequency values, the first
 column  is an integer that indicates the number of steps, the second number
 is  the initial frequency, and the third number the final frequency. If the
 first  number  is one, then only the initial value is considered. The block
 can have any number of rows. Consider the next example: 

 %EMFreqs 
 31 | 0.0 | 1.0 
  1 | 0.32 
 % 

END

Variable EMFreqsSort
Type logical
Default true
Section Linear Response::Polarizabilities
Description
 If true, the frequencies specified by the EMFreqs block are sorted, so that
 they  are  calculated  in  increasing order. Can be set to false to use the
 order  as  stated,  in  case  this  makes  better  use of available restart
 information. 
END

Variable EMEta
Type float
Default 0.0
Section Linear Response::Polarizabilities
Description
 The  imaginary  part  of the frequency, effectively a Lorentzian broadening
 for peaks in the spectrum. It can help convergence of the SCF cycle for the
 Sternheimer  equation when on a resonance, and it can be used as a positive
 infinitesimal to get the imaginary parts of response functions at poles. In
 units of energy. Cannot be negative. 
END

Variable EMPerturbationType
Type integer
Default electric
Section Linear Response::Polarizabilities
Description
 Which perturbation to consider for electromagnetic linear response. 
Option electric 1
 Electric  perturbation  used  to  calculate  electric  polarizabilities and
 hyperpolarizabilities. 
Option magnetic 2
 Magnetic perturbation used to calculate magnetic susceptibilities. 
Option none 0
 Zero perturbation, for use in testing. 
END

Variable EMHyperpol
Type block
Section Linear Response::Polarizabilities
Description
 This  block  describes  the multiples of the frequency used for the dynamic
 hyperpolarizability.  The  results  are  written  to  the  file beta in the
 directory for the first multiple. 
END

Variable EMForceNoKdotP
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 If  the  system is periodic, by default wavefunctions from a previous kdotp
 run  will  be  read,  to be used in the formulas for the polarizability and
 hyperpolarizability  in  the  quantum  theory  of polarization. For testing
 purposes, you can set this variable to true to disregard the kdotp run, and
 use  the  formulas for the finite system. This variable has no effect for a
 finite system. 
END

Variable EMCalcBornCharges
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Calculate linear-response Born effective charges from electric perturbation
 (experimental). 
END

Variable EMCalcRotatoryResponse
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Calculate circular-dichroism spectrum from electric perturbation, and write
 to file rotatory_strength. 
END

Variable EMOccupiedResponse
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Solve  for  full  response  without projector into unoccupied subspace. Not
 possible if there are partial occupations. 
END

Variable EMWavefunctionsFromScratch
Type logical
Default false
Section Linear Response::Polarizabilities
Description
 Do  not  use  saved  linear-response  wavefunctions  from a previous run as
 starting  guess.  Instead initialize to zero as in FromScratch, but restart
 densities  will  still be used. Restart wavefunctions from a very different
 frequency can hinder convergence. 
END

Variable KdotPOccupiedSolutionMethod
Type integer
Default sternheimer
Section Linear Response::KdotP
Description
 Method  of  calculating  the  contribution  of  the  projection  of  the
 linear-response wavefunctions in the occupied subspace. 
Option sternheimer_eqn 0
 The  Sternheimer equation is solved including the occupied subspace, to get
 the full linear-response wavefunctions. 
Option sum_over_states 1
 The  Sternheimer  equation is solved only in the unoccupied subspace, and a
 sum-over-states  perturbation-theory  expression  is  used  to evaluate the
 contributions in the occupied subspace. 
END

Variable KdotPEta
Type float
Default 0.0
Section Linear Response::KdotP
Description
 Imaginary  frequency  added  to  Sternheimer  equation  which  may  improve
 convergence. Not recommended. 
END

Variable KdotPCalculateEffectiveMasses
Type logical
Default true
Section Linear Response::KdotP
Description
 If  true,  uses  kdotp  perturbations  of  ground-state  wavefunctions  to
 calculate effective masses. 
END

Variable vdWNPoints
Type integer
Section Linear Response::Polarizabilities
Description
 How  many points to use in the Gauss-Legendre integration to obtain the van
 der Waals coefficients. The default is 6. 
END

Variable Preorthogonalization
Type logical
Section Linear Response::Sternheimer
Description
 Whether  initial  linear-response wavefunctions should be orthogonalized or
 not against the occupied states, at the start of each SCF cycle. Default is
 true only if SmearingFunction = semiconducting, or if the Occupations block
 specifies all full or empty states. 
END

Variable HamiltonianVariation
Type integer
Default hartree+fxc
Section Linear Response::Sternheimer
Description
 The  terms  to  be considered in the variation of the Hamiltonian. V_ext is
 always  considered. The default is to include also the exchange-correlation
 and  Hartree  terms,  which  fully  takes  into  account local fields. Just
 hartree  gives  you  the  random-phase  approximation (RPA). If you want to
 choose the exchange-correlation kernel, use the variable 
 XCKernel.  For  kdotp  and  magnetic  em_resp  modes,  or  if TheoryLevel =
 independent_particles,  the  value  V_ext_only is used and this variable is
 ignored. 
Option V_ext_only 0
 Neither Hartree nor XC potentials included. 
Option hartree 1
 The variation of the Hartree potential only. 
Option fxc 2
 The  exchange-correlation kernel (the variation of the exchange-correlation
 potential) only. 
END

Variable TypeOfMixing
Type integer
Default broyden
Section SCF::Mixing
Description
 The  scheme used to produce, at each iteration in the self-consistent cycle
 that  attempts to solve the Kohn-Sham equations, the input density from the
 value of the input and output densities of previous iterations. 
Option linear 0
 Simple linear mixing. 
Option gr_pulay 1
 "Guaranteed-reduction"  Pulay scheme [D. R. Bowler and M. J. Gillan, _Chem.
 Phys. Lett._ *325*, 473 (2000)]. 
Option broyden 2
 Broyden  scheme  [C.  G  Broyden,  _Math.  Comp._  *19*,  577 (1965); D. D.
 Johnson, _Phys. Rev. B_ *38*, 12807 (1988)]. 
END

Variable Mixing
Type float
Default 0.3
Section SCF::Mixing
Description
 Both  the linear and the Broyden scheme depend on a "mixing parameter", set
 by this variable. Must be 0 < Mixing <= 1. 
END

Variable MixNumberSteps
Type integer
Default 3
Section SCF::Mixing
Description
 In  the Broyden and GR-Pulay schemes, the new input density or potential is
 constructed  from  the values of the densities/potentials of a given number
 of  previous  iterations.  This  number  is  set  by this variable. Must be
 greater than 1. 
END

Variable ODESolver
Type integer
Default ode_rk4
Section Math::General
Description
 Specifies what kind of ODE solver will be used. 
Option ode_rk4 1
 Standard Runge-Kutta, 4th order. 
Option ode_fb78 2
 Fehlberg solver. 
Option ode_vr89 3
 Verner solver. 
Option ode_pd89 4
 Prince-Dormand solver. 
END

Variable ODESolverNSteps
Type integer
Default 100
Section Math::General
Description
 Number  of  steps  which  the  chosen  ODE  solver  should  perform  in the
 integration interval [a,b] of the ODE. 
END

Variable RootSolver
Type integer
Default root_newton
Section Math::General
Description
 Specifies what kind of root solver will be used. 
Option root_bisection 1
 Bisection method. 
Option root_brent 2
 Brent method. 
Option root_newton 3
 Newton method. 
Option root_laguerre 4
 Laguerre method. 
Option root_watterstrom 5
 Watterstrom method. 
END

Variable RootSolverMaxIter
Type integer
Default 100
Section Math::General
Description
 In  case  of an iterative root solver, this variable determines the maximum
 number of iteration steps. 
END

Variable RootSolverRelTolerance
Type float
Default 1e-8
Section Math::General
Description
 Relative tolerance for the root-finding process. 
END

Variable RootSolverAbsTolerance
Type float
Default 1e-8
Section Math::General
Description
 Relative tolerance for the root-finding process. 
END

Variable RootSolverHavePolynomial
Type logical
Default no
Section Math::General
Description
 If  set to yes, the coefficients of the polynomial have to be passed to the
 root solver. 
END

Variable RootSolverWSRadius
Type float
Default 1.0
Section Math::General
Description
 Radius  of  circle  in  the complex plane. If RootSolverWSRadius = 1.0, the
 unit roots of an _n_th-order polynomial are taken as initial values. 
END

Variable WatterstromODESolver
Type integer
Default ode_pd89
Section Math::General
Description
 The  Watterstrom  method  (_J. Comp. Phys._ *8*, 304-308 (1971)) transforms
 finding  roots  for  _n_th-order  polynomials  into  the  solution  of  _n_
 uncoupled  ODEs. This variable specifies the solver that should be used for
 the  ODE  stepping.  Valid solver types are those allowed for the ODESolver
 variable. 
Option ode_rk4 1
 Standard 4th-order Runge-Kutta. 
Option ode_fb78 2
 Fehlberg solver. 
Option ode_vr89 3
 Verner solver. 
Option ode_pd89 4
 Prince-Dormand solver. 
END

Variable WatterstromODESolverNSteps
Type integer
Default 400
Section Math::General
Description
 Number  of  steps  which  the  chosen  ODE  solver  should  perform  in the
 integration interval [_a_, _b_] of the Watterstrom ODE. 
END

Variable SPARSKITSolver
Type integer
Default sk_cg
Section Math::General
Description
 Specifies what kind of linear solver will be used. 
Option sk_cg 1
 Conjugate Gradient Method 
Option sk_cgnr 2
 Conjugate Gradient Method (Normal Residual equation) 
Option sk_bcg 3
 Bi-Conjugate Gradient Method 
Option sk_dbcg 4
 BCG with partial pivoting 
Option sk_bcgstab 5
 BCG stabilized 
Option sk_tfqmr 6
 Transpose-Free Quasi-Minimum Residual method 
Option sk_fom 7
 Full Orthogonalization Method 
Option sk_gmres 8
 Generalized Minimum Residual method 
Option sk_fgmres 9
 Flexible version of Generalized Minimum Residual method 
Option sk_dqgmres 10
 Direct versions of the Quasi-Generalized Minimum Residual method 
END

Variable SPARSKITKrylovSubspaceSize
Type integer
Default 15
Section Math::General
Description
 Some  of  the  SPARSKIT  solvers are Krylov subspace methods. This variable
 determines what size the solver will use for the subspace. 
END

Variable SPARSKITMaxIter
Type integer
Default 0
Section Math::General
Description
 This  variable  controls the maximum number of iteration steps that will be
 performed by the (iterative) linear solver. 
END

Variable SPARSKITIterOut
Type integer
Default 0
Section Math::General
Description
 Determines how often status info of the solver is printed. 
END

Variable SPARSKITRelTolerance
Type float
Default 1e-8
Section Math::General
Description
 Some  SPARSKIT solvers use a relative tolerance as a stopping criterion for
 the  iterative  solution  process. This variable can be used to specify the
 tolerance. 
END

Variable SPARSKITAbsTolerance
Type float
Default 1e-8
Section Math::General
Description
 Some SPARSKIT solvers use an absolute tolerance as a stopping criterion for
 the  iterative  solution  process. This variable can be used to specify the
 tolerance. 
END

Variable SPARSKITVerboseSolver
Type logical
Default no
Section Math::General
Description
 When set to yes, the SPARSKIT solver will write more detailed output. 
END

Variable TDFunctions
Type block
Section Time-Dependent
Description
 This  block specifies the shape of a "time-dependent function", such as the
 envelope  needed  when  using  the TDExternalFields block. Each line in the
 block  specifies  one  function.  The  first element of each line will be a
 string  that defines the name of the function. The second element specifies
 which type of function we are using; in the following we provide an example
 for each of the possible types: 

 (1) tdf_cw 

 %TDFunctions 
    "function-name" | tdf_cw | amplitude 
 % 

 The function is just a constant of value amplitude. 

  f(t) = amplitude 

 (2) tdf_gaussian 

 %TDFunctions 
    "function-name" | tdf_gaussian | amplitude | tau0 | t0 
 % 

 The function is a Gaussian: 

  f(t) = F_0 exp( - (t-t_0)/(2\tau_0^2) )  

 F_0 = amplitude. 

 (3) tdf_cosinoidal 

 %TDFunctions 
    "function-name" | tdf_cosinoidal | amplitude | tau0 | t0 
 % 

  f(t) = F_0 cos( \pi/2 \frac{t-2\tau_0-t_0}{\tau0} )  

 If  | t - t_0 | > \tau_0 , then  f(t) = 0 . 

 (4) tdf_trapezoidal 

 %TDFunctions 
    "function-name" | tdf_trapezoidal | amplitude | tau0 | t0 | tau1 
 % 

 The function ramps linearly during tau_1 time units, stays constant for 
 tau_0  time  units,  and  the  decays to zero linearly again for tau_1 time
 units. 

 (5) tdf_from_file 

 %TDFunctions 
    "function-name" | tdf_from_file | "filename" 
 % 

 The  temporal shape of the function is contained in a file called filename.
 This  file  should  contain three columns: first column is time, second and
 third  column  are  the  real  part  and the imaginary part of the temporal
 function _f_(_t_). 

 (A.6) tdf_from_expr 

 %TDFunctions 
    "function-name" | tdf_from_expr | "expression" 
 % 

 The  temporal  shape  of  the  field  is  given  as  an  expression  (e.g.,
 "cos(2.0*t)".  The letter _t_ means time, obviously. The expression is used
 to construct the function _f_ that defines the field: 

Option tdf_cw 10002
 Explained above. 
Option tdf_gaussian 10003
 Explained above. 
Option tdf_cosinoidal 10004
 Explained above. 
Option tdf_trapezoidal 10005
 Explained above. 
Option tdf_from_file 10006
 Explained above. 
Option tdf_from_expr 10008
 Explained above. 
END

Variable FFTOptimize
Type logical
Default yes
Section Mesh::FFTs
Description
 Should  octopus optimize the FFT dimensions? This means that the cubic mesh
 to  which  FFTs  are  applied is not taken to be as small as possible: some
 points  may  be added to each direction in order to get a "good number" for
 the  performance of the FFT algorithm. In some cases, namely when using the
 split-operator, or Suzuki-Trotter propagators, this option should be turned
 off. 
END

Variable FFTPreparePlan
Type integer
Default fftw_measure
Section Mesh::FFTs
Description
 The  FFTs  are  performed  in  octopus  with  the  help of the FFTW package
 (http://www.fftw.org).  Before  doing the actual computations, this package
 prepares  a  "plan",  which means that the precise numerical strategy to be
 followed  to  compute  the FFT is machine/compiler-dependent, and therefore
 the software attempts to figure out which is this precise strategy (see the
 FFTW  documentation  for  details).  This plan preparation, which has to be
 done  for each particular FFT shape, can be done exhaustively and carefully
 (slow),  or  merely  estimated.  Since  this is a rather critical numerical
 step,  by  default  it  is  done  carefully, which implies a longer initial
 initialization,  but  faster  subsequent  computations. You can change this
 behaviour by changing this FFTPreparePlan variable, and in this way you can
 force  FFTW  to  do  a fast guess or estimation of which is the best way to
 perform the FFT. 
Option fftw_measure 0
 This  is  the  default, and implies a longer initialization, but involves a
 more  careful  analysis  of  the  strategy  to  follow,  and therefore more
 efficient FFTs. 
Option fftw_estimate 64
 This  is  the  "fast  initialization"  scheme,  in which the plan is merely
 guessed from "reasonable" assumptions. 
END

Variable PFFTOptimize
Type logical
Default yes
Section Mesh::FFTs
Description
 Should  octopus optimize the FFT dimensions? This means that the cubic mesh
 to  which  FFTs  are  applied is not taken to be as small as possible: some
 points  may  be added to each direction in order to get a "good number" for
 the  performance of the FFT algorithm. In some cases, namely when using the
 split-operator, or Suzuki-Trotter propagators, this option should be turned
 off. 
END

Variable PFFTPreparePlan
Type integer
Default pfft_measure
Section Mesh::FFTs
Description
 The  FFTs  are  performed  in  octopus  with  the help of the PFFT and FFTW
 package  (http://www.fftw.org).  Before doing the actual computations, this
 package  prepares a "plan", which means that the precise numerical strategy
 to  be  followed  to  compute  the  FFT  is machine/compiler-dependent, and
 therefore  the  software  attempts  to  figure  out  which  is this precise
 strategy  (see  the FFTW documentation for details). This plan preparation,
 which  has  to  be  done  for  each  particular  FFT  shape,  can  be  done
 exhaustively  and  carefully  (slow),  or merely estimated. Since this is a
 rather  critical  numerical  step,  by  default it is done carefully, which
 implies  a  longer  initial  initialization,  but  faster  subsequent
 computations.  You  can  change  this  behaviour  by  changing  this
 PFFTPreparePlan  variable,  and in this way you can force PFFT to do a fast
 guess or estimation of which is the best way to perform the FFT. 
Option pfft_measure 0
 This  is  the  default, and implies a longer initialization, but involves a
 more  careful  analysis  of  the  strategy  to  follow,  and therefore more
 efficient FFTs. 
Option pfft_estimate 64
 This  is  the  "fast  initialization"  scheme,  in which the plan is merely
 guessed from "reasonable" assumptions. 
END

Variable PFFTOutput
Type logical
Default no
Section Mesh::FFTs
Description
 Should octopus print the FFT values? 
END

Variable OCTInitialState
Type integer
Section Calculation Modes::Optimal Control
Default 1
Description
 Describes the initial state of the quantum system. Possible arguments are: 
Option oct_is_groundstate 1
 Start in the ground state. 
Option oct_is_excited 2
 Currently not in use. 
Option oct_is_gstransformation 3
 Start  in  a transformation of the ground-state orbitals, as defined in the
 block OCTInitialTransformStates. 
Option oct_is_userdefined 4
 Start in a userdefined state. 
END

Variable OCTInitialTransformStates
Type block
Section Calculation Modes::Optimal Control
Description
 If OCTInitialState = oct_is_gstransformation, you must specify an 
 OCTInitialTransformStates  block,  in  order  to  specify  which  linear
 combination  of  the  states  present  in  restart/gs is used to create the
 initial state. 

 The syntax is the same as the TransformStates block. 
END

Variable OCTInitialUserdefined
Type block
Section Calculation Modes::Optimal Control
Description
 Define  an  initial  state. Syntax follows the one of the UserDefinedStates
 block. Example: 

 %OCTInitialUserdefined 
    1 | 1 | 1 | "exp(-r^2)*exp(-i*0.2*x)" 
 % 

END

Variable OCTControlRepresentation
Type integer
Section Calculation Modes::Optimal Control
Default control_function_real_time
Description
 Optimal  Control  Theory  can  be  performed  with Octopus in two different
 modes:  either  considering the control function to be described in full in
 real  time,  or to be represented by a set of parameters (which may, or may
 not be, the coefficients of its expansion in a given basis). The particular
 choice  for  these  parameters  is  specified  by  variable
 OCTParameterRepresentation  (this  variable  will be ignored if the control
 function is to be represented directly in real time). 
Option control_function_real_time 1
 The control functions are represented directly in real time. 
Option control_function_parametrized 2
 The control functions are specified by a set of parameters. 
END

Variable OCTScheme
Type integer
Section Calculation Modes::Optimal Control
Default oct_algorithm_zbr98
Description
 Optimal  Control  Theory  can  be  performed with Octopus with a variety of
 different algorithms. Not all of them can be used with any choice of target
 or  control function representation. For example, some algorithms cannot be
 used if 
 OCTControlRepresentation  =  control_function_real_time  (OCTScheme  .gt.
 oct_algorithm_straight_iteration),  and  others  cannot  be  used  if
 OCTControlRepresentation  =  control_function_parametrized  (OCTScheme .lt.
 oct_algorithm_straight_iteration). 
Option oct_algorithm_zbr98 1
 Backward-Forward-Backward  scheme  described  in  _JCP_ *108*, 1953 (1998).
 Only  possible  if target operator is a projection operator. Provides fast,
 stable and monotonic convergence. 
Option oct_algorithm_zr98  2
 Forward-Backward-Forward scheme described in _JCP_ *109*, 385 (1998). Works
 for  projection  and more general target operators also. The convergence is
 stable  but  slower than ZBR98. Note that local operators show an extremely
 slow convergence. It ensures monotonic convergence. 
Option oct_algorithm_wg05  3
 Forward-Backward  scheme  described  in _J. Opt. B._ *7*, 300 (2005). Works
 for  all  kinds of target operators, can be used with all kinds of filters,
 and  allows a fixed fluence. The price is a rather unstable convergence. If
 the  restrictions  set  by  the  filter  and fluence are reasonable, a good
 overlap can be expected within 20 iterations. No monotonic convergence. 
Option oct_algorithm_mt03 4
 Basically an improved and generalized scheme. Comparable to ZBR98/ZR98. See
 [Y. Maday and G. Turinici, _J. Chem. Phys._ *118*, 8191 (2003)]. 
Option oct_algorithm_krotov 5
 The  procedure  reported  in  [D.  Tannor,  V.  Kazakov  and  V.  Orlov, in
 _Time-Dependent Quantum Molecular Dynamics_, edited by J. Broeckhove and L.
 Lathouweres (Plenum, New York, 1992), pp. 347-360]. 
Option oct_algorithm_straight_iteration 6
 Straight  iteration:  one forward and one backward propagation is performed
 at  each  iteration,  both  with the same control field. An output field is
 calculated  with  the  resulting  wavefunctions.  Note  that  this  scheme
 typically does not converge, unless some mixing (OCTMixing = yes) is used. 
Option oct_algorithm_cg 7
 Conjugate-gradients, as implemented in the GNU GSL library. 
Option oct_algorithm_direct 8
 This  is a "direct" optimization scheme. This means that we do not make use
 of  the "usual" QOCT equations (backward-forward propagations, etc), but we
 use some gradient-free maximization algorithm for the function that we want
 to  optimize.  In  this case, the maximization algorithm is the Nelder-Mead
 algorithm  as  implemeted  in  the GSL. The function values are obtained by
 successive forward propagations. 
Option oct_algorithm_newuoa 9
 This  is  exactly the same as oct_algorithm_direct, except in this case the
 maximization  algorithm is the so-called NEWUOA algorithm [M. J. D. Powell,
 _IMA J. Numer. Analysis_ 
 *28*, 649-664 (2008)]. 
END

Variable OCTDoubleCheck
Type logical
Section Calculation Modes::Optimal Control
Default true
Description
 In  order  to  make  sure that the optimized field indeed does its job, the
 code  may  run  a  normal  propagation  after  the  optimization  using the
 optimized field. 
END

Variable OCTCheckGradient
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 When  doing  QOCT  with  the  conjugate-gradient  optimization  scheme, the
 gradient  is  computed  thanks  to  a  forward-backwards  propagation.  For
 debugging  purposes,  this gradient can be compared with the value obtained
 "numerically" (_i.e._ by doing successive forward propagations with control
 fields separated by small finite differences). 

 In  order  to  activate this feature, set OCTCheckGradient to some non-zero
 value,  which will be the finite difference used to numerically compute the
 gradient. 
END

Variable OCTMixing
Type logical
Section Calculation Modes::Optimal Control
Default false
Description
 Use  mixing  algorithms  to  create  the  input fields in the iterative OCT
 schemes.  Note  that  this  idea  is  still  a little bit experimental, and
 depending  on  the kind of mixing that you use, and the parameters that you
 set,  it  may  or  may  not  accelerate  the convergence, or even spoil the
 convergence. 

 Using  TypeOfMixing = broyden, Mixing = 0.1 and MixNumberSteps = 3 seems to
 work in many cases, but your mileage may vary. 

 Note  that  mixing  does  not  make  sense (and is therefore not done, this
 variable  being  ignored),  for  some  OCT  algorithms  (in  particular, if
 OCTScheme is 
 oct_algorithm_direct or oct_algorithm_newuoa). 
END

Variable OCTDirectStep
Type float
Section Calculation Modes::Optimal Control
Default 0.25
Description
 If  you  choose  OCTScheme  =  oct_algorithm_direct  or  OCTScheme  =
 oct_algorithm_newuoa,  the  algorithms  necessitate  an  initial  "step" to
 perform  the  direct  search  for the optimal value. The precise meaning of
 this "step" differs. 
END

Variable OCTDumpIntermediate
Type logical
Section Calculation Modes::Optimal Control
Default true
Description
 Writes  to  disk  some data during the OCT algorithm at intermediate steps.
 This  is  rather  technical  and it should be considered only for debugging
 purposes.  Nevertheless,  since  the  whole OCT infrastructure is at a very
 preliminary stage of development, it is set to true by default. 
END

Variable OCTNumberCheckPoints
Type integer
Section Calculation Modes::Optimal Control
Default 0
Description
 During  an  OCT  propagation,  the code may write the wavefunctions at some
 time  steps  (the  "check  points").  When  the inverse backward or forward
 propagation  is  performed  in  a  following  step, the wavefunction should
 reverse its path (almost) exactly. This can be checked to make sure that it
 is the case -- otherwise one should try reducing the time-step, or altering
 in some other way the variables that control the propagation. 

 If  the backward (or forward) propagation is not retracing the steps of the
 previous forward (or backward) propagation, the code will write a warning. 
END

Variable OCTRandomInitialGuess
Type logical
Section Calculation Modes::Optimal Control
Default false
Description
 The  initial field to start the optimization search is usually given in the
 inp  file,  through a TDExternalFields block. However, you can start from a
 random guess if you set this variable to true. 

 Note,  however,  that  this  is  only  valid  for the "direct" optimization
 schemes; moreover you still need to provide a TDExternalFields block. 
END

Variable OCTFilter
Type block
Section Calculation Modes::Optimal Control
Description
 The  block  OCTFilter  describes  the type and shape of the filter function
 that are applied to the optimized laser field in each iteration. The filter
 forces  the  laser  field to obtain the given form in frequency space. Each
 line  of  the block describes a filter; this way you can actually have more
 than  one  filter  function  (_e.g._  a filter in time and two in frequency
 space).  The  filters  are  applied  in  the given order, _i.e._, first the
 filter specified by the first line is applied, then second line. The syntax
 of each line is, then: 

 %OCTFilter 
   domain | function 
 % 


 Possible arguments for domain are: 

 (i) frequency_filter: Specifies a spectral filter. 

 (ii) time_filter: DISABLED IN THIS VERSION. 

 Example: 

 %OCTFilter 
   time | "exp(-80*( w + 0.1567 )^2 ) + exp(-80*( w - 0.1567 )^2 )" 
 % 

 Be careful that also the negative-frequency component is filtered since the
 resulting field has to be real-valued. 

Option frequency_filter 1
 The filter is applied in the frequency domain. 
END

Variable OCTEps
Type float
Section Calculation Modes::Optimal Control
Default 1.0e-6
Description
 Define  the  convergence  threshold. It computes the difference between the
 "input"  field  in the iterative procedure, and the "output" field. If this
 difference is less than OCTEps the iteration is stopped. This difference is
 defined as: 

  D[\epsilon^{i},\epsilon^{o}]  =  \int_0^T  dt  \vert
 \epsilon^{i}(t)-\epsilon^{o}(t)\vert^2\,. 
  

 (If there are several control fields, this difference is defined as the sum
 over all the individual differences.) 

 Whenever  this  condition  is  satisfied,  it  means that we have reached a
 solution  point  of the QOCT equations, _i.e._ a critical point of the QOCT
 functional  (not  necessarily  a  maximum,  and  not necessarily the global
 maximum). 
END

Variable OCTMaxIter
Type integer
Section Calculation Modes::Optimal Control
Default 10
Description
 The maximum number of iterations. Typical values range from 10-100. 
END

Variable OCTControlFunctionRepresentation
Type integer
Section Calculation Modes::Optimal Control
Default control_fourier_series_h
Description
 If  OCTControlRepresentation  =  control_function_parametrized,  one  must
 specify  the  kind  of  parameters  that determine the control function. If
 OCTControlRepresentation  =  control_function_real_time, then this variable
 is ignored, and the control function is handled directly in real time. 
Option control_sine_fourier_series_h 2
 The  control  function  is expanded in a sine Fourier series (which implies
 that  it it starts and ends at zero). Then, the total fluence is fixed, and
 a  transformation  to hyperspherical coordinates is done; the parameters to
 optimize are the hyperspherical angles. 
Option control_fourier_series_h 3
 The  control  function  is  expanded  as a full Fourier series (although it
 must, of course, be a real function). Then, the total fluence is fixed, and
 a  transformation  to hyperspherical coordinates is done; the parameters to
 optimize are the hyperspherical angles. 
Option control_zero_fourier_series_h 4
 The control function is expanded as a Fourier series, but assuming (1) that
 the  zero  frequency  component  is  zero,  and  (2)  the control function,
 integrated in time, adds up to zero (this essentially means that the sum of
 all the cosine coefficients is zero). Then, the total fluence is fixed, and
 a  transformation  to hyperspherical coordinates is done; the parameters to
 optimize are the hyperspherical angles. 
Option control_fourier_series 5
 The  control  function  is  expanded  as a full Fourier series (although it
 must,  of  course,  be  a  real  function).  The control parameters are the
 coefficients of this basis-set expansion. 
Option control_zero_fourier_series 6
 The  control  function  is  expanded  as a full Fourier series (although it
 must,  of  course,  be  a  real  function).  The control parameters are the
 coefficients  of  this  basis-set expansion. The difference with the option
 control_fourier_series  is  that  (1)  that the zero-frequency component is
 zero,  and  (2)  the  control function, integrated in time, adds up to zero
 (this  essentially  means  that  the  sum of all the cosine coefficients is
 zero). 
END

Variable OCTControlFunctionOmegaMax
Type float
Section Calculation Modes::Optimal Control
Default -1.0
Description
 The Fourier series that can be used to represent the control functions must
 be  truncated;  the  truncation  is  given  by a cut-off frequency which is
 determined by this variable. 
END

Variable OCTFixFluenceTo
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 The  algorithm  tries  to obtain the specified fluence for the laser field.
 This  works  only  in  conjunction  with  either  the  WG05 or the straight
 iteration scheme. 

 If this variable is not present in the input file, by default the code will
 not  attempt a fixed-fluence QOCT run. The same holds if the value given to
 this variable is exactly zero. 

 If this variable is given a negative value, then the target fluence will be
 that  of  the  initial  laser pulse given as guess in the input file. Note,
 however,  that  first  the  code  applies  the  envelope  provided  by  the
 OCTLaserEnvelope input option, and afterwards it calculates the fluence. 
END

Variable OCTFixInitialFluence
Type logical
Section Calculation Modes::Optimal Control
Default yes
Description
 By default, when asking for a fixed-fluence optimization (OCTFixFluenceTo =
 whatever),  the initial laser guess provided in the input file is scaled to
 match  this fluence. However, you can force the program to use that initial
 laser  as  the  initial  guess,  no  matter  the  fluence,  by  setting
 OCTFixInitialFluence = no. 
END

Variable OCTControlFunctionType
Type integer
Section Calculation Modes::Optimal Control
Default controlfunction_mode_epsilon
Description
 The  control  function  may  fully determine the time-dependent form of the
 external  field,  or  only the envelope function of this external field, or
 its  phase.  Or,  we  may have two different control functions, one of them
 providing the phase and the other one, the envelope. 

 Note  that,  if OCTControlRepresentation = control_function_real_time, then
 the control function must *always* determine the full external field. 
Option controlfunction_mode_epsilon   1
 In  this  case,  the control function determines the full control function:
 namely,  if  we  are  considering  the  electric  field  of  a  laser,  the
 time-dependent electric field. 
Option controlfunction_mode_f         2
 The  optimization  process attempts to find the best possible envelope. The
 full  control  field  is  this  envelope  times  a  cosine  function with a
 "carrier"  frequency.  This  carrier  frequency  is  given  by  the carrier
 frequency of the TDExternalFields in the inp file. 
Option controlfunction_mode_phi       3
 The  optimization process attempts to find the best possible time-dependent
 phase. That is, the external field would be given by a function in the form
 e(t)  =  f(t)*cos(w0*t+phi(t)),  where  f(t) is an "envelope", w0 a carrier
 frequency, and phi(t) the td phase that we wish to optimize. 
END

Variable OCTPenalty
Type float
Section Calculation Modes::Optimal Control
Default 1.0
Description
 The  variable  specifies the value of the penalty factor for the integrated
 field  strength  (fluence).  Large value = small fluence. A transient shape
 can  be specified using the block OCTLaserEnvelope. In this case OCTPenalty
 is  multiplied  with  time-dependent  function.  The  value  depends on the
 coupling between the states. A good start might be a value from 0.1 (strong
 fields) to 10 (weak fields). 

 Note  that  if  there  are  several control functions, one can specify this
 variable  as a one-line code, each column being the penalty factor for each
 of  the control functions. Make sure that the number of columns is equal to
 the  number  of  control  functions.  If  it  is  not  a block, all control
 functions will have the same penalty factor. 

 All penalty factors must be positive. 
END

Variable OCTLaserEnvelope
Type block
Section Calculation Modes::Optimal Control
Description
 Often  a  pre-defined  time-dependent  envelope  on the control function is
 desired.  This can be achieved by making the penalty factor time-dependent.
 Here, you may specify the required time-dependent envelope. 

 It  is  possible  to  choose  different  envelopes  for  different  control
 functions.  There  should  be one line for each control function. Each line
 should have only one element: a string with the function that defines the 
 *inverse* of the time-dependent penalty, which is then defined as 1 divided
 by (this function + 1.0e-7) (to avoid possible singularities). 

 The usual choices should be functions between zero and one. 

 If, instead of defining a function, the string is default, then the program
 will use the function: 

  \frac{1}{\alpha(t)}  =  \frac{1}{2}(  erf((100/T)*(t-T/20))+
 erf(-(100/T)*(t-T+T/20))  
END

Variable OCTTargetOperator
Type integer
Section Calculation Modes::Optimal Control
Default oct_tg_gstransformation
Description
 The  variable  OCTTargetOperator prescribes which kind of target functional
 is to be used. 
Option oct_tg_groundstate 1
 The  target  operator  is a projection operator on the ground state, _i.e._
 the objective is to populate the ground state as much as possible. 
Option oct_tg_excited 2
 The  target  operator  is  an  "excited  state". This means that the target
 operator is a linear combination of Slater determinants, each one formed by
 replacing  in  the  ground-state Slater determinant one occupied state with
 one  excited  state (_i.e._ "single excitations"). The description of which
 excitations  are  used,  and  with which weights, should be given in a file
 called 
 oct-excited-state-target.  This  is still in very preliminary, experimental
 phase.  See  the  documentation  of  subroutine  excited_states_init in the
 source code in order to use this feature. 
Option oct_tg_gstransformation 3
 The  target  operator  is  a projection operator on a transformation of the
 ground-state orbitals defined by the block OCTTargetTransformStates. 
Option oct_tg_userdefined 4
 Allows to define target state by using OCTTargetUserdefined. 
Option oct_tg_density 5
 The  target operator is a given density, _i.e._ the final state should have
 a  density  as close as possible as the one given in the input file, either
 from the variable 
 OCTTargetDensityFromState,  or from OCTTargetDensity. It can be extended to
 a combination with a current functional by setting OCTCurrentFunctional and
 attributing a value to OCTCurrentWeight. 
Option oct_tg_local 6
 The target operator is a local operator. 
Option oct_tg_td_local 7
 The target operator is a time-dependent local operator. 
Option oct_tg_exclude_state 8
 Target  operator  is  the  projection onto the complement of a given state,
 given  by  the  block  OCTTargetTransformStates. This means that the target
 operator is the unity operator minus the projector onto that state. 
Option oct_tg_hhg 9
 The target is the optimization of the HHG yield. 
Option oct_tg_velocity 10
 The  target is a function of the velocities of the nuclei at the end of the
 influence of the external field, defined by OCTVelocityTarget 
Option oct_tg_current 11
 The  target  is  exclusively  a target in terms of the current. If combined
 with  target  that  involves  the  density, set variable OCTTargetOperator=
 OCTTargetDensity  and  set  explicitly  OCTCurrentFunctional.  Only  this
 combination is enabled. All other targets force 
 OCTCurrentFunctional=0. 
END

Variable OCTExcludedStates
Type string
Section Calculation Modes::Optimal Control
Description
 If  the  target  is the exclusion of several targets, ("OCTTargetOperator =
 oct_exclude_states") then you must declare which states are to be excluded,
 by  setting  the  OCTExcludedStates variable. It must be a string in "list"
 format:  "1-8",  or  "2,3,4-9",  for example. Be careful to include in this
 list  only  states  that have been calculated in a previous "gs" or "unocc"
 calculation, or otherwise the error will be silently ignored. 
END

Variable OCTTargetTransformStates
Type block
Default no
Section Calculation Modes::Optimal Control
Description
 If OCTTargetOperator = oct_tg_gstransformation, you must specify a 
 OCTTargetTransformStates  block,  in  order  to  specify  which  linear
 combination  of  the  states  present  in  restart/gs is used to create the
 target state. 

 The syntax is the same as the TransformStates block. 
END

Variable OCTTargetUserdefined
Type block
Section Calculation Modes::Optimal Control
Description
 Define  a  target  state.  Syntax  follows the one of the UserDefinedStates
 block. Example: 

 %OCTTargetUserdefined 
    1 | 1 | 1 | "exp(-r^2)*exp(-i*0.2*x)" 
 % 

END

Variable OCTTargetDensity
Type string
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  =  oct_tg_density,  then  one must supply the target
 density  that should be searched for. This one can do by supplying a string
 through the variable OCTTargetDensity. 
END

Variable OCTTargetDensityFromState
Type block
Default no
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  =  oct_tg_density,  and  OCTLocalTarget  =
 "OCTTargetDensityFromState",  you  must  specify  a  OCTTargetDensityState
 block,  in  order to specify which linear combination of the states present
 in restart/gs is used to create the target density. 

 The syntax is the same as the TransformStates block. 
END

Variable OCTLocalTarget
Type string
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  = oct_tg_local, then one must supply a function that
 defines  the  target.  This should be done by defining it through a string,
 using the variable OCTLocalTarget. 
END

Variable OCTOptimizeHarmonicSpectrum
Type block
Default no
Section Calculation Modes::Optimal Control
Description
 WARNING: Experimental 

 If  OCTTargetOperator  =  oct_tg_hhg,  the  target is the harmonic emission
 spectrum.  In  that  case,  you  must supply an OCTOptimizeHarmonicSpectrum
 block in the inp file. The target is given, in general, by: 

 J_1 = \int_0^\infty d\omega \alpha(\omega) H(\omega), 

 where H(\omega) is the harmonic spectrum generated by the system, and 
 \alpha(\omega)  is  some  function  that determines what exactly we want to
 optimize. The role of the OCTOptimizeHarmonicSpectrum block is to determine
 this \alpha(\omega) function. Currently, this function is defined as: 

 \alpha(\omega)  =  \sum_{L=1}^{M}  \frac{\alpha_L}{a_L}  \sqcap(  (\omega -
 L\omega_0)/a_L ), 

 where  omega_0  is the carrier frequency. M is the number of columns in the
 OCTOptimizeHarmonicSpectrum  block. The values of _L_ will be listed in the
 first row of this block;  alpha_L  in the second row, and a_L in the third.
 

 Example: 

 %OCTOptimizeHarmonicSpectrum 
    7 | 9 | 11 
    -1 | 1 | -1 
    0.01 | 0.01 | 0.01 
 % 

END

Variable OCTVelocityTarget
Type block
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator = oct_tg_velocity, then one must supply the target to
 optimize  in  terms  of  the  ionic velocities. This is done by supplying a
 string  trough  the  block  OCTVelocityTarget.  Each  velocity component is
 supplied  by  "v[n_atom,vec_comp]",  while  "n_atom" is the respective atom
 number, corresponding to the 
 Coordinates  block  and "vec_comp" is the corresponding vector component of
 the  velocity.  The target string can be supplied by using several lines in
 the  OCTTargetOperator  block.  As  an example, the following target can be
 used  to  maximize  the  velocity  difference between atom 1 and 2 (in a 3D
 system): 

 %OCTVelocityTarget 
  "(v[1,1]-v[2,1])^2 + (v[1,2]-v[2,2])^2 + " 
  "(v[1,3]-v[2,3])^2" 
 % 

END

Variable OCTVelocityDerivatives
Type block
Section Calculation Modes::Optimal Control
Description
 If OCTTargetOperator = oct_tg_velocity, and 
 OCTScheme  =  oct_algorithm_cg  then you must supply the target in terms of
 the  ionic velocities AND the derivatives of the target with respect to the
 ionic  velocity components. The derivatives are supplied via strings trough
 the block 
 OCTVelocityDerivatives.  Each  velocity  component  is  supplied  by
 "v[n_atom,vec_comp]",  while  "n_atom" is the atom number, corresponding to
 the 
 Coordinates  block  and "vec_comp" is the corresponding vector component of
 the velocity. The first line of the 
 OCTVelocityDerivatives  block  contains  the  derivatives  with  respect to
 "v[1,*]",  the  second with respect to "v[2,*]" and so on. The first column
 contains  all derivatives with respect "v[*,1]", the second with respect to
 "v[*,2]"  and  the  third  w.r.t.  "v[*,3]".  As  an  example,  we show the
 OCTVelocityDerivatives  block  corresponding  to  the  target  shown in the
 OCTVelocityTarget help section: 

 %OCTVelocityDerivatives 
  " 2*(v[1,1]-v[2,1])" | " 2*(v[1,2]-v[2,2])" | " 2*(v[1,3]-v[2,3])"  
  "-2*(v[1,1]-v[2,1])" | "-2*(v[1,2]-v[2,2])" | "-2*(v[1,3]-v[2,3])"  
 % 

END

Variable OCTMoveIons
Type logical
Section Calculation Modes::Optimal Control
Description
 If  OCTTargetOperator  = oct_tg_velocity, then one must specify if the ions
 are assumed to be fixed or if they can move by setting 
 OCTMoveIons to true or false. 
END

Variable OCTCurrentFunctional
Type integer
Section Calculation Modes::Optimal Control
Default oct_no_curr
Description
 The  variable  OCTCurrentFunctional  describes which kind of current target
 functional J1_c[j] is to be used. EXPERIMENTAL! 
Option oct_no_curr 0
 No current functional is used, no current calculated. 
Option oct_curr_square 1
 Calculates the square of current j: J1_c[j] = OCTCurrentWeight*\int|j(r)|^2
 dr.  For  OCTCurrentWeight  .LT. 0 the current will be minimized (useful in
 combination  with  target  density  in  order to obtain stable final target
 density), while for OCTCurrentWeight .GT. 0 it will be maximized (useful in
 combination  with  a  target  density  in  order  to obtain a high-velocity
 impact, for instance). It is a static target, to be reached at total time. 
Option oct_max_curr_ring 2
 Maximizes  the  current  of a quantum ring in one direction. The functional
 maximizes  the  z  projection  of  the  outer  product between the position
 \vec{r}  and  the  current  \vec{j}: J1[j] = OCTCurrentWeight*\int (\vec{r}
 \times  \vec{j}) \hat{z} dr. For OCTCurrentWeight .GT. 0. the current flows
 in  counter  clockwise  direction,  while  for  OCTCurrentWeight .LT. 0 the
 current is clockwise. 
Option oct_curr_square_td 3
 The  time  dependent  version  of  oct_curr_square. In fact, calculates the
 square  of  current  in  time  interval  [OCTStartTimeCurrTg,  total time =
 TDMaximumIter * TDTimeStep]. Set TDPropagator  = crank_nicholson 
END

Variable OCTCurrentWeight
Type float
Section Calculation Modes::Optimal Control
Default 0.0
Description
 In  the  case  of simultaneous optimization of density n and current j, one
 can  tune  the  importance  of  the  current  functional  J1_c[j],  as  the
 respective  functionals  might  not  provide  results  on the same scale of
 magnitude.  J1[n,j]= J1_d[n]+ OCTCurrentWeight * J1_c[j]. Be aware that its
 sign is crucial for the chosen OCTCurrentFunctional as explained there. 
END

Variable OCTStartIterCurrTg
Type integer
Section Calculation Modes::Optimal Control
Default 0
Description
 Allows  for a time dependent target for the current without defining it for
 the  total  time-interval  of the simulation. Thus it can be switched on at
 the  iteration  desired,  OCTStartIterCurrTg  .ge. 0 and OCTStartIterCurrTg
 .lt.  TDMaximumIter.  Tip:  If  you  would  like to specify a real time for
 switching  the  functional  on  rather  than  the number of steps, just use
 something like: 
 OCTStartIterCurrTg = 100.0 / TDTimeStep 
END

Variable OCTSpatialCurrWeight
Type block
Section Calculation Modes::Optimal Control
Description
 Can  be  seen  as  a  position dependent OCTCurrentWeight. Consequently, it
 weights  contribution  of  current j to its functional J1_c[j] according to
 the  position in space. For example, oct_curr_square thus becomes J1_c[j] =
 OCTCurrentWeight \int |j(r)|^2 OCTSpatialCurrWeight(r) dr. 

 It  is  defined  OCTSpatialCurrWeight(r)  =  g(x)*g(y)*g(z),  where  g(x) =
 \sum_{i}  1/(1+exp(  -fact*(x-startpoint_i)  ))  -  1/(1+exp(
 -fact*(x-endpoint_i) )). If not specified, g(x) = 1. 

 Each  g(x)  is  represented by one line of the block that has the following
 form 

 %OCTSpatialCurrWeight 
    dimension | fact | startpoint_1 | endpoint_1 | startpoint_2 | endpoint_2
 |... 
 % 

 There  are  no  restrictions  on  the number of lines, nor on the number of
 pairs  of  start- and endpoints. Attention: startpoint and endpoint have to
 be  supplied  pairwise  with  startpoint .lt. endpoint. dimension .gt. 0 is
 integer, fact is float. 
END

Variable PDBCoordinates
Type string
Section System::Coordinates
Description
 If  this  variable  is  present,  the  program  tries  to  read  the atomic
 coordinates  from  the  file  specified by its value. The PDB (Protein Data
 Bank, 
 http://www.rcsb.org/pdb/)  format  is  quite  complicated, and it goes well
 beyond  the  scope of this manual. You can find a comprehensive description
 <a  href='http://www.wwpdb.org/docs.html'>here</a>.  From  the  plethora of
 instructions  defined in the PDB standard, Octopus only reads two, ATOM and
 HETATOM. From these fields, it reads: 
  
  *)  columns 13-16: The species; in fact Octopus only cares about the first
 letter  -  "CA"  and  "CB"  will  both  refer to carbon - so elements whose
 chemical symbol has more than one letter cannot be represented in this way.
 So,  if  you  want  to  run  mercury  (Hg), please use one of the other two
 methods to input the coordinates: XYZCoordinates or Coordinates. 
  *)  columns  18-21:  The residue. If residue is QM, the atom is treated by
 quantum  mechanics; otherwise it is simply treated as an external classical
 point charge. Its charge will be given by columns 61-65. 
  *)  columns  31-54:  The  Cartesian  coordinates.  The  Fortran  format is
 (3f8.3). 
  *)  columns  61-65:  Classical  charge  of the atom. The Fortran format is
 (f6.2). 
  
END

Variable XYZCoordinates
Type string
Section System::Coordinates
Description
 If  PDBCoordinates is not present, the program reads the atomic coordinates
 from  the XYZ file specified by the variable XYZCoordinates -- in case this
 variable  is  present. The XYZ format is very simple: The first line of the
 file  has an integer indicating the number of atoms. The second can contain
 comments that are simply ignored by 
 Octopus.  Then  there  follows  one  line per atom, containing the chemical
 species and the Cartesian coordinates of the atom. 
END

Variable Coordinates
Type block
Section System::Coordinates
Description
 If  neither  XYZCoordinates  nor PDBCoordinates was found, Octopus tries to
 read  the  coordinates for the atoms from the block Coordinates. The format
 is quite straightforward: 

 %Coordinates 
   'C' | -0.56415 | 0.0 | 0.0 | no 
   'O' |  0.56415 | 0.0 | 0.0 | no 
 % 

 The  first  line  defines  a carbon atom at coordinates ("-0.56415", "0.0",
 "0.0"),  that  is  *not*  allowed to move during dynamical simulations. The
 second  line  has  a similar meaning. This block obviously defines a carbon
 monoxide  molecule,  if  the input units are eV_Angstrom. Note that in this
 way  it  is  possible  to  fix some of the atoms (this is not possible when
 specifying the coordinates through a PDBCoordinates or 
 XYZCoordinates  file).  It  is always possible to fix *all* atoms using the
 MoveIons directive. 
END

Variable ReducedCoordinates
Type block
Section System::Coordinates
Description
 This  block  gives  the  atomic coordinates relative to the real space unit
 cell. The format is the same as the 
 Coordinates block. 

 Note  that  in  Octopus  the  origin of coordinates is in the center of the
 cell, so the coordinates inside the cell are in the range [-0.5, 0.5). 

 This block cannot be used with the minimum box shapes. 

END

Variable SpeciesTimeDependent
Type logical
Default no
Section System::Species
Description
 When  this  variable  is set, the potential defined in the block Species is
 calculated  and applied to the Hamiltonian at each time step. You must have
 at least one spec_user_defined type of species to use this. 
END

Variable IonicInteraction
Type block
Section System::Species
Description
 This  block  defines  the  type of classical interaction between ions. Each
 line represents the interaction between two types of species. The first two
 columns  contain  the  element  symbols,  the  next  column  is the type of
 interaction  as  defined below. The next columns are the parameters for the
 interaction (if any). Pairs not specified interact through Coulomb`s law. 

 Note:  In  most cases there is no need to specify this block, since Coulomb
 interaction will be used by default. 

Option coulomb 1
 Particles  interact according to Coulomb`s law. The interaction strength is
 given by the charge of the species. There are no parameters. 
Option lennard_jones 2
 (Experimental) The Lennard-Jones 12-6 model potential. It has the form V(r)
 = 4\epsilon((\sigma/r)^12 - (\sigma/r)^6). The next 2 columns contain the 
 \epsilon and \sigma (given in the corresponding input file units). 
END

Variable SymmetryBreakDir
Type block
Section Mesh::Simulation Box
Description
 This  variable  specifies  a  direction in which the symmetry of the system
 will  be  broken.  This  is  useful  for generating _k_-point grids when an
 external perturbation is applied. 
END

Variable MainAxis
Type block
Section Utilities::oct-center-geometry
Description
 A  vector  of three reals defining the axis to which the molecule should be
 aligned. If not present, the default value will be: 
 %MainAxis 
  1 | 0 | 1 
 % 
END

Variable AxisType
Type integer
Default inertia
Section Utilities::oct-center-geometry
Description
 After  the structure is centered, it is also aligned to a set of orthogonal
 axes. This variable decides which set of axes to use. 
Option inertia 1
 The axis of inertia. 
Option pseudo_inertia 2
 Pseudo-axis  of  inertia,  calculated considering all species to have equal
 mass. 
Option large_axis 3
 The larger axis of the molecule. 
END

Variable DoubleFFTParameter
Type float
Default 2.0
Section Mesh::FFTs
Description
 For  solving  the  Poisson  equation in Fourier space, and for applying the
 local  potential  in  Fourier space, an auxiliary cubic mesh is built. This
 mesh  will  be  larger  than  the circumscribed cube of the usual mesh by a
 factor DoubleFFTParameter. See the section that refers to Poisson equation,
 and  to  the  local  potential  for  details  [the  default value of two is
 typically good]. 
END

Variable PeriodicDimensions
Type integer
Default 0
Section System
Description
 Define  how  many  directions are to be considered periodic. It has to be a
 number between zero and Dimensions. 
Option 0
 No direction is periodic (molecule). 
Option 1
 The _x_ direction is periodic (wire, polymer). 
Option 2
 The _x_ and _y_ directions are periodic (slab). 
Option 3
 The _x_, _y_, and _z_ directions are periodic (bulk). 
END

Variable ComplexBoundaries
Type logical
Default no
Section System
Description
 (Experimental)  If  enabled the system will have complex boundaries defined
 by an electrostatic potential. Must be used with the SETE poisson solver. 
END

Variable MultiResolutionArea
Type block
Section Mesh
Description
 (Experimental)  Multiresolution  regions  are  set with this parameter. The
 first  three  numbers  define  the  central  point  of  the region, and the
 following  ones  set  the radii where resolution changes (measured from the
 central  point).  NOTE:  currently,  only  one area can be set up, and only
 works in 3D. 
END

Variable MultiResolutionInterpolationOrder
Type integer
Default 5
Section Mesh
Description
 The interpolation order in multiresolution approach. The default is 5. 
END

Variable BoxShape
Type integer
Default minimum
Section Mesh::Simulation Box
Description
 This  variable  decides  the  shape  of  the simulation box. Note that some
 incompatibilities apply: 
  
  *) Spherical or minimum mesh is not allowed for periodic systems. 
  *)  Cylindrical  mesh is not allowed for systems that are periodic in more
 than one dimension. 
  *) Box_image is only allowed in 2D. 
  
Option sphere 1
 The simulation box will be a sphere of radius Radius. 
Option cylinder 2
 The  simulation  box  will  be a cylinder with radius Radius and height two
 times 
 Xlength. 
Option minimum 3
 The  simulation  box  will  be constructed by adding spheres created around
 each atom (or user-defined potential), of radius Radius. 
Option parallelepiped 4
 The simulation box will be a parallelepiped whose dimensions are taken from
 the variable Lsize. 
Option box_image 5
 The  simulation  box will be defined through an image. White means that the
 point  is contained in the simulation box, while any other color means that
 the point is out. 
Option user_defined 77
 The  shape  of  the  simulation  box  will  be  read  from  the  variable
 BoxShapeUsDef. 
Option hypercube 6
 (experimental)  The  simulation  box  will  be  a  hypercube  or
 hyperparallelepiped. This is equivalent to the 
 parallelepiped box but it can work with an arbitrary number of dimensions. 
END

Variable Radius
Type float
Section Mesh::Simulation Box
Description
 Defines  the  radius for BoxShape = sphere, cylinder, or minimum. Must be a
 positive  number.  If not specified, the code will look for a default value
 in  the  Species block, or, if default pseudopotentials are used, the rsize
 column of 
 share/PP/defaults.  For  minimum, a default radius is chosen separately for
 each species. 
END

Variable Xlength
Type float
Section Mesh::Simulation Box
Description
 If BoxShape is cylinder, the total length of the cylinder is twice Xlength.
 The default is Radius. 
END

Variable Lsize
Type block
Section Mesh::Simulation Box
Description
 If BoxShape is parallelepiped, hypercube, 
 box_image, or user_defined, this is a block of the form: 

 %Lsize 
   sizex | sizey | sizez | ... 
 % 

 where the size* are half the lengths of the box in each direction. 

 The  number of columns must match the dimensionality of the calculation. If
 you want a cube you can also set Lsize as a single variable. 
END

Variable BoxShapeImage
Type string
Section Mesh::Simulation Box
Description
 Name of the file that contains the image that defines the simulation box. 
END

Variable BoxShapeUsDef
Type string
Section Mesh::Simulation Box
Description
 Boolean  expression  that  defines  the interior of the simulation box. For
 example, 
 BoxShapeUsDef  =  "(sqrt(x^2+y^2)  <= 4) && z>-2 && z<2" defines a cylinder
 with axis parallel to the _z_-axis. 
END

Variable BoxOffset
Type float
Default 0.0
Section Mesh::Simulation Box
Description
 Shifts  the zero of the simulation box, relative to the atomic coordinates,
 by a specified vector. It can be either a float, interpreted as (x,x,x), or
 a  block  containing  the (x,y,z) value of the zero. WARNING: This variable
 does not seem to work correctly! 
END

Variable LatticeVectors
Type block
Default simple cubic
Section Mesh::Simulation Box
Description
 Primitive  lattice  vectors.  Vectors  are  stored in rows. Note that these
 vectors will be normalized to 1 after being read. Default: 
 %LatticeVectors 
   1.0 | 0.0 | 0.0 
   0.0 | 1.0 | 0.0 
   0.0 | 0.0 | 1.0 
 % 
END

Variable MoveIons
Type logical
Default no
Section Time-Dependent::Propagation
Description
 This  variable  controls  whether atoms are moved during a time propagation
 run. The default is no. 
END

Variable Thermostat
Type integer
Default none
Section Time-Dependent::Propagation
Description
 This  variable  selects the type of thermostat applied to control the ionic
 temperature. 
Option none 0
 No thermostat is applied. This is the default. 
Option velocity_scaling 1
 Velocities are scaled to control the temperature. 
Option nose_hoover 2
 Nose-Hoover thermostat. 
END

Variable TemperatureFunction
Type integer
Default none
Section Time-Dependent::Propagation
Description
 If  a  thermostat is used, this variable indicates the name function of the
 TDFunctions that will be used to control the temperature. The values of the
 temperature are given in degrees Kelvin. The default name for this function
 is "temperature". 
END

Variable ThermostatMass
Type float
Default 1.0
Section Time-Dependent::Propagation
Description
 This  variable sets the fictitious mass for the Nose-Hoover thermostat. The
 default is 1.0. 
END

Variable RandomVelocityTemp
Type float
Section System::Velocities
Description
 If  this  variable is present, Octopus will assign random velocities to the
 atoms  following  a  Boltzmann  distribution  with  temperature  given  by
 RandomVelocityTemp (in degrees Kelvin). 
END

Variable XYZVelocities
Type string
Section System::Velocities
Description
 Octopus  will try to read the starting velocities of the atoms from the XYZ
 file  specified by the variable XYZVelocities. Note that you do not need to
 specify initial velocities if you are not going to perform ion dynamics; if
 you  are  going  to  allow  the  ions  to  move  but the velocities are not
 specified, they are considered to be null. 
END

Variable Velocities
Type block
Section System::Velocities
Description
 If  XYZVelocities  is  not  present,  octopus will try to fetch the initial
 atomic  velocities  from  this block. If this block is not present, octopus
 will  reset the initial velocities to zero. The format of this block can be
 illustrated by this example: 

 %Velocities 
   'C' | -1.7 | 0.0 | 0.0 
   'O' |  1.7 | 0.0 | 0.0 
 % 

 It  describes  one carbon and one oxygen moving at the relative velocity of
 3.4 velocity units. 

 Note:  It is important for the velocities to maintain the ordering in which
 the species were defined in the coordinates specifications. 
END

Variable KPointsUseSymmetries
Type logical
Default no
Section Mesh::KPoints
Description
 This  variable defines whether symmetries are taken into account or not for
 the  choice  of _k_-points. If it is set to no, the _k_-point sampling will
 range  over the full Brillouin zone. Symmetries should not be used whenever
 a perturbation is applied to the system. 
END

Variable KPointsUseTimeReversal
Type logical
Default yes
Section Mesh::KPoints
Description
 *WARNING:  This  variable  does  not  seem  to work.* This variable defines
 whether  time-reversal symmetry is taken into account or not for the choice
 of  _k_-points.  If  it  is  set  to no, the _k_-point sampling will not be
 reduced  according  to  time-reversal  symmetry.  The  default  is  yes. If
 KPointsUseSymmetries  =  no,  this  variable  is ignored, and time-reversal
 symmetry is not used. 
END

Variable KPointsGrid
Type block
Default Gamma-point only
Section Mesh::KPoints
Description
 When this block is given (and the KPoints block is not present), 
 _k_-points are distributed in a uniform grid. 

 The  first row of the block is a triplet of integers defining the number of
 _k_-points to be used along each direction in reciprocal space. The numbers
 refer  to  the whole Brillouin zone, and the actual number of _k_-points is
 usually  reduced  exploiting  the  symmetries of the system. By default the
 grid  will  always  include  the  Gamma  point.  An optional second row can
 specify a shift in the _k_-points. 

 For example, the following input samples the BZ with 100 points in the 
 _xy_-plane of reciprocal space: 

 %KPointsGrid 
   10 | 10 | 1 
 % 

END

Variable KPoints
Type block
Section Mesh::KPoints
Description
 This  block  defines  an explicit set of _k_-points and their weights for a
 periodic-system  calculation.  The  first  column  is  the  weight  of each
 _k_-point and the following are the components of the _k_-point vector. You
 only  need to specify the components for the periodic directions. Note that
 the  _k_-points  should  be  given in Cartesian coordinates (not in reduced
 coordinates),  _i.e._  what  Octopus  writes  in a line in the ground-state
 standard output as 
 #k = 1, k = ( 0.154000, 0.154000, 0.154000). 

 For example, if you want to include only the Gamma point, you can use: 

 %KPoints 
   1.0 | 0 | 0 | 0 
 % 

END

Variable KPointsReduced
Type block
Section Mesh::KPoints
Description
 Same  as  the  block  KPoints  but  this time the input is given in reduced
 coordinates. 
END

Variable SubspaceDiagonalization
Type integer
Default standard
Section SCF::Eigensolver
Description
 Selects  the  method  to  perform  subspace diagonalization. The default is
 standard,  unless  states  parallelization  is  used,  when  the default is
 scalapack. 
Option standard 1
 The standard routine. Can be used with domain parallelization but not state
 parallelization. 
Option old 2
 Old routine, compatible with states parallelization. 
Option scalapack 3
 State-parallelized  version  using  ScaLAPACK.  (Requires  that Octopus was
 compiled with ScaLAPACK support.) 
END

Variable OutputMatrixElements
Type flag
Default no
Section Output
Description
 Specifies  what  matrix  elements  to  print.  The output files go into the
 static directory, except when running a time-dependent simulation, when the
 directory td.XXXXXXX is used. Example: "momentum + ks_multipoles" 
Option momentum 1
 TODO 
Option ang_momentum 2
 TODO 
Option one_body 4
 &lt;i|T + V_{ext}|j&gt; 
Option two_body 8
 &lt;ij| 1/|r_1-r_2| |kl&gt; 
Option ks_multipoles 16
 TODO 
END

Variable OutputMEMultipoles
Type integer
Default 1
Section Output
Description
 This  variable  decides which multipole moments are printed out: _e.g._, if
 1,  then  the  program  will  print three files, ks_multipoles.x (x=1,2,3),
 containing  respectively  the  (1,-1),  (1,0)  and  (1,1)  multipole matrix
 elements between Kohn-Sham states. 
END

Variable InvertKSmethod
Type integer
Default iterative
Section Calculation Modes::Invert KS
Description
 Selects  whether  the  exact two-particle method or the iterative scheme is
 used to invert the density to get the KS potential. 
Option iterative 1
 Iterative scheme for v_s. 
Option two_particle 2
 Exact two-particle scheme. 
Option iterativevxc 3
 Iterative scheme for v_xc. 
END

Variable KSInversionLevel
Type integer
Default ks_inversion_adiabatic
Section Hamiltonian::XC
Description
 At what level shall Octopus handle the KS inversion 
Option ks_inversion_none 1
 Do not compute KS inversion 
Option ks_inversion_adiabatic 2
 Compute exact adiabatic vxc 
END

Variable InvertKSConvAbsDens
Type float
Default 1e-5
Section Calculation Modes::Invert KS
Description
 Absolute difference between the calculated and the target density in the KS
 inversion.  Has to be larger than the convergence of the density in the SCF
 run. 
END

Variable InvertKSStabilizer
Type float
Default 0.5
Section Calculation Modes::Invert KS
Description
 Additive  constant  _c_  in  the  iterative calculation of the KS potential
 (v(alpha+1)=rho(alpha)+c)/(rho_target+c)*v(alpha)  ensures  that very small
 densities do not cause numerical problems. 
END

Variable InvertKSVerbosity
Type integer
Default 0
Section Calculation Modes::Invert KS
Description
 Selects what is output during the calculation of the KS potential. 
Option 0
 Only outputs the converged density and KS potential. 
Option 1
 Same  as 0 but outputs the maximum difference to the target density in each
 iteration in addition. 
Option 2
 Same as 1 but outputs the density and the KS potential in each iteration in
 addition. 
END

Variable TDExponentialMethod
Type integer
Default taylor
Section Time-Dependent::Propagation
Description
 Method  used to numerically calculate the exponential of the Hamiltonian, a
 core part of the full algorithm used to approximate the evolution operator,
 specified  through  the  variable  TDPropagator.  In  the case of using the
 Magnus method, described below, the action of the exponential of the Magnus
 operator  is  also  calculated  through  the  algorithm  specified  by this
 variable. 
Option lanczos 2
 Allows for larger time-steps. However, the larger the time-step, the longer
 the computational time per time-step. In certain cases, if the time-step is
 too  large,  the  code  will  emit a warning whenever it considers that the
 evolution  may  not  be  properly proceeding -- the Lanczos process did not
 converge.  The  method  consists  in a Krylov subspace approximation of the
 action  of  the exponential (see M. Hochbruck and C. Lubich, SIAM J. Numer.
 Anal.  *34*,  1911  (1997)  for  details).  Two  more variables control the
 performance  of  the  method:  the  maximum  dimension  of  this  subspace
 (controlled by variable TDExpOrder), and the stopping criterion (controlled
 by  variable  TDLanczosTol).  The  smaller the stopping criterion, the more
 precisely  the exponential is calculated, but also the larger the dimension
 of  the Arnoldi subspace. If the maximum dimension allowed by TDExpOrder is
 not enough to meet the criterion, the above-mentioned warning is emitted. 
Option taylor 3
 This  method  amounts to a straightforward application of the definition of
 the exponential of an operator, in terms of its Taylor expansion. 

 <MATH>\exp_{\rm  STD}  (-i\delta  t  H)  =  \sum_{i=0}^{k}  {(-i\delta
 t)^i\over{i!}} H^i.</MATH> 

 The  order  _k_  is  determined  by  variable  _TDExpOder_.  Some numerical
 considerations  (by  Jeff  Giansiracusa  and  George  F.  Bertsch;  see
 http://www.phys.washington.edu/~bertsch/num3.ps)  suggest  the 4th order as
 especially suitable and stable. 
Option chebyshev 4
 In principle, the Chebyshev expansion of the exponential represents it more
 accurately than the canonical or standard expansion. As in the latter case,
 TDExpOrder determines the order of the expansion. 

 There exists a closed analytic form for the coefficients of the exponential
 in terms of Chebyshev polynomials: 

 <MATH>\exp_{\rm  CHEB}  \left(  -i\delta  t H \right) = \sum_{k=0}^{\infty}
 (2-\delta_{k0})(-i)^{k}J_k(\delta t) T_k(H),</MATH> 

 where  J_k  are  the  Bessel  functions  of the first kind, and H has to be
 previously scaled to [-1,1]. See H. Tal-Ezer and R. Kosloff, J. Chem. Phys.
 *81*,  3967 (1984); R. Kosloff, Annu. Rev. Phys. Chem. *45*, 145 (1994); C.
 W. Clenshaw, MTAC *9*, 118 (1955). 
END

Variable TDLanczosTol
Type float
Default 1e-5
Section Time-Dependent::Propagation
Description
 An  internal  tolerance  variable  for the Lanczos method. The smaller, the
 more  precisely  the  exponential  is  calculated,  and also the bigger the
 dimension  of  the  Krylov  subspace  needed  to perform the algorithm. One
 should  carefully  make  sure  that  this value is not too big, or else the
 evolution will be wrong. 
END

Variable TDExpOrder
Type integer
Default 4
Section Time-Dependent::Propagation
Description
 For  TDExponentialMethod  =  standard  or chebyshev, the order to which the
 exponential  is  expanded.  For  the  Lanczos  approximation,  it  is  the
 Lanczos-subspace dimension. 
END

Variable LinearSolver
Type integer
Default qmr_symmetric
Section Linear Response::Solver
Description
 Method  for  solving  linear  equations, which occur for Sternheimer linear
 response  and  OEP.  The  solvers  vary  in  speed, reliability (ability to
 converge), and domain of applicability. QMR solvers are most reliable. 
Option bicgstab 4
 Biconjugate  gradients  stabilized.  Slower  than  cg,  but  more reliable.
 General matrices. 
Option cg 5
 Conjugate  gradients.  Fast but unreliable. Hermitian matrices only (no eta
 in Sternheimer). 
Option multigrid 7
 Multigrid  solver,  currently  only  Gauss-Jacobi (experimental). Slow, but
 fairly reliable. General matrices. 
Option qmr_symmetric 81
 Quasi-minimal  residual  solver,  for  (complex)  symmetric matrices. [Real
 symmetric  is  equivalent  to Hermitian.] Slightly slower than bicgstab but
 more  reliable.  For  Sternheimer, must be real wavefunctions, but can have
 eta. 
Option qmr_symmetrized 82
 Quasi-minimal  residual  solver, using the symmetrized form A^T A x = A^T y
 instead of A x = y. Reliable but very slow. General matrices. 
Option qmr_dotp 83
 Quasi-minimal  residual solver, for Hermitian matrices, using the symmetric
 algorithm  with conjugated dot product (experimental). Slightly slower than
 bicgstab but more reliable. Can always be used in Sternheimer. 
Option qmr_general 84
 Quasi-minimal residual solver, for general matrices, using the most general
 form of the algorithm. Slow and unreliable. 
Option sos 9
 Sum  over  states: the Sternheimer equation is solved by using the explicit
 solution  in  terms  of the ground-state wavefunctions. You need unoccupied
 states  to  use  this  method.  Unlike  the other methods, may not give the
 correct answer. 
END

Variable LinearSolverMaxIter
Type integer
Default 1000
Section Linear Response::Solver
Description
 Maximum number of iterations the linear solver does, even if convergence is
 not achieved. 
END

Variable MagneticGaugeCorrection
Type integer
Default gipaw
Section Linear Response
Description
 For  magnetic  linear  response:  how  to  handle  gauge-invariance  in the
 description of the coupling of electrons to the magnetic field. 
Option none 0
 No correction. 
Option gipaw 1
 GIPAW  correction:  C  Pickard and F Mauri, _Phys. Rev. Lett._ *91*, 196401
 (2003). 
Option icl 2
 ICL  correction: S Ismail-Beigi, EK Chang, and SG Louie, _Phys. Rev. Lett._
 *87*, 087402 (2001). 
END

Variable KdotPUseNonLocalPseudopotential
Type logical
Default true
Section Linear Response::KdotP
Description
 For  testing  purposes,  set to false to ignore the term -i[r,V] in the k.p
 perturbation, which is due to non-local pseudopotentials. 
END

Variable ELFWithCurrentTerm
Type logical
Default true
Section Output
Description
 The  ELF,  when calculated for complex wavefunctions, should contain a term
 dependent  on  the  current.  This  term is properly calculated by default;
 however,  for  research  purposes  it  may be useful not to add it. If this
 feature proves to be useless, this option should go away. 
END

Variable Preconditioner
Type integer
Default filter
Section SCF::Eigensolver
Description
 Which  preconditioner  to  use in order to solve the Kohn-Sham equations or
 the linear-response equations. May apply prefix of linear-response (_e.g._ 
 EM, KdotP, VM) to differentiate from choice for ground state. 
Option no 0
 Do not apply preconditioner. 
Option pre_filter 1
 Filter preconditioner. 
Option pre_jacobi 2
 Jacobi  preconditioner. Only the local part of the pseudopotential is used.
 Not very helpful. 
Option pre_poisson 3
 Uses  the  full  Laplacian  as  preconditioner.  The  inverse is calculated
 through  the  solution  of  the  Poisson equation. This is, of course, very
 slow. 
Option pre_multigrid 7
 Multigrid preconditioner. 
END

Variable TheoryLevel
Type integer
Default dft
Section Hamiltonian
Description
 The calculations can be run with different "theory levels": 
Option independent_particles 2
 Particles  will  be  considered  as independent, _i.e._ as non-interacting.
 This  mode is mainly used for testing purposes, as the code is usually much
 faster with independent_particles. 
Option hartree 1
 Calculation  within  the Hartree method (experimental). Note that, contrary
 to  popular  belief,  the  Hartree  potential  is  self-interaction-free.
 Therefore,  this  run  mode  will  not yield the same result as dft without
 exchange-correlation. 
Option hartree_fock 3
 This is the traditional Hartree-Fock scheme. Like the Hartree scheme, it is
 fully  self-interaction-free. This mode is extremely slow. It is often more
 convenient  to  use  dft  within the OEP scheme to get similar (but not the
 same)  results.  Note  that  within  this  scheme you can use a correlation
 functional,  or a hybrid functional (see XCFunctional). In the latter case,
 you will be following the quantum-chemistry recipe to use hybrids. 
Option dft 4
 This  is  the  default  density-functional theory scheme. Note that you can
 also  use  hybrids  in this scheme, but they will be handled the "DFT" way,
 _i.e._, solving the OEP equation. 
Option classical 5
 (Experimental)  Only  the classical interaction between ions is considered.
 This is mainly for testing. 
END

Variable SICCorrection
Type integer
Default sic_none
Section Hamiltonian::XC
Description
 This  variable  controls  which form of self-interaction correction to use.
 Note  that  this  correction  will  be  applied to the functional chosen by
 XCFunctional. 
Option sic_none 1
 No self-interaction correction. 
Option sic_pz 2
 Perdew-Zunger SIC, handled by the OEP technique. 
Option sic_amaldi 3
 Amaldi correction term. 
END

Variable XCTailCorrection
Type logical
Default no
Section Hamiltonian::XC
Description
 (Experimental)  This  variable  applies a correction to the value of the XC
 functional  in  near-zero-density  regions.  This zone might have numerical
 noise or it might even be set to zero by libxc. The correction is performed
 by  forcing  the  "-1/_r_ behaviour" of the XC potential in the zones where
 the density is lower then XCTailCorrectionTol. 
END

Variable XCTailCorrectionTol
Type float
Default 5-e12
Section Hamiltonian::XC
Description
This variable sets the total electronic density threshold corresponding
 to the starting point of the XCTailCorrection. 
The value is always assumed to be in atomic units.
END

Variable XCTailCorrectionLinkFactor
Type float
Default 1
Section Hamiltonian::XC
Description
 (Experimental)  This variable forces a smooth transition between the region
 where  the  values of the XC functional have been previously calculated and
 the  region where the -1/_r_ correction has been applied. The region of the
 transition  starts  where the electronic total density reaches the value of
 (XCTailCorrectionLinkFactor  *  XCTailCorrectionTol)  and  ends  where  the
 density reaches the value of XCTailCorrectionTol. 
END

Variable XCTailCorrectionDelay
Type integer
Default 0
Section Hamiltonian::XC
Description
 (Experimental)  This  variable skips the application of the tail correction
 during  the  first  calls  of  the  subroutine  that  build  the
 exchange-correlation  potential  (XCTailCorrectionDelay  =  number of calls
 skipped): 
this can avoid problems caused by initial guess wavefunctions.
END

Variable XCTailCorrectionCMDistance
Type integer
Default 0
Section Hamiltonian::XC
Description
 (Experimental)  This variable allows the application of the tail correction
 to  the  XC  potential  only where the distance of the local point from the
 center of mass of the system is greater than 
 XCTailCorrectionCMDistance. 
END

Variable OEPLevel
Type integer
Default oep_kli
Section Hamiltonian::XC
Description
 At  what level shall Octopus handle the optimized effective potential (OEP)
 equation. 
Option oep_none 1
 Do not solve OEP equation. 
Option oep_slater 2
 Slater approximation. 
Option oep_kli 3
 Krieger-Li-Iafrate  (KLI)  approximation  (JB  Krieger,  Y  Li, GJ Iafrate,
 _Phys. Rev. Lett. A_ *146*, 256 (1990). 
Option oep_full 5
 (Experimental)  Full  solution  of  OEP  equation  using  the  Sternheimer
 approach. 
END

Variable OEPMixing
Type float
Default 1.0
Section Hamiltonian::XC
Description
 The linear mixing factor used to solve the Sternheimer equation in the full
 OEP procedure. The default is 1.0. 
END

Variable Eigensolver
Type integer
Section SCF::Eigensolver
Description
 Which  eigensolver  to  use  to  obtain  the  lowest  eigenvalues  and
 eigenfunctions  of  the  Kohn-Sham  Hamiltonian.  The  default is conjugate
 gradients  (cg);  when parallelization in states is enabled, the default is
 lobpcg. 
Option cg 5
 Conjugate-gradients algorithm. 
Option plan 11
 Preconditioned Lanczos scheme. 
Option cg_new 6
 An  alternative  conjugate-gradients eigensolver, faster for larger systems
 but less mature. 
Option evolution 9
 Propagation  in  imaginary time. WARNING: Sometimes it misbehaves. Use with
 caution. 
Option lobpcg 8
 (Experimental)  Locally  optimal  block-preconditioned  conjugate-gradient
 algorithm.  Ref: A. Knyazev, Toward the Optimal Preconditioned Eigensolver:
 Locally  Optimal  Block  Preconditioned  Conjugate  Gradient  Method, _SIAM
 Journal on Scientific Computing_, 23(2):517-541, 2001. 
Option rmmdiis 10
 Residual  minimization  scheme,  direct inversion in the iterative subspace
 eigensolver, based on the implementation of Kresse and Furthmüller [_Phys.
 Rev.  B_  *54*,  11169  (1996)].  This  eigensolver  requires  almost  no
 orthogonalization  so  it can be considerably faster than the other options
 for  large  systems; however it might suffer stability problems. To improve
 its  performance  a large number of ExtraStates are required (around 10-20%
 of the number of occupied states). 
Option multigrid 7
 (Experimental) Multigrid eigensolver. 
END

Variable EigensolverVerbose
Type logical
Default no
Section SCF::Eigensolver
Description
 If enabled, the eigensolver prints additional information. 
END

Variable EigensolverSubspaceDiag
Type logical
Default yes
Section SCF::Eigensolver
Description
 Allows  you to turn off subspace diagonalization during the diagonalization
 of  the  Hamiltonian.  Subspace  diagonalization sometimes creates problems
 when  restarting  unoccupied-states  calculations  with  a larger number of
 unoccupied states. 
END

Variable EigensolverImaginaryTime
Type float
Default 10.0
Section SCF::Eigensolver
Description
 The imaginary-time step that is used in the imaginary-time evolution method
 (Eigensolver = evolution) to obtain the lowest eigenvalues/eigenvectors. It
 must satisfy EigensolverImaginaryTime > 0. 
END

Variable EigensolverMinimizationIter
Type integer
Default 5
Section SCF::Eigensolver
Description
 During  the  first  iterations,  the  RMMDIIS  eigensolver  requires  some
 steepest-descent  minimizations  to  improve  convergence.  This  variable
 determines the number of those minimizations. The default is 5. 
END

Variable EigensolverInitTolerance
Type float
Default 1.0e-6
Section SCF::Eigensolver
Description
 This is the initial tolerance for the eigenvectors. 
END

Variable EigensolverFinalTolerance
Type float
Default 1.0e-6
Section SCF::Eigensolver
Description
 This  is  the  final  tolerance  for the eigenvectors. Must be smaller than
 EigensolverInitTolerance. 
END

Variable EigensolverFinalToleranceIteration
Type integer
Default 7
Section SCF::Eigensolver
Description
 Determines  how  many  iterations  are  needed  to  go  from
 EigensolverInitTolerance  to EigensolverFinalTolerance. Must be larger than
 1. 
END

Variable EigensolverMaxIter
Type integer
Section SCF::Eigensolver
Description
 Determines  the  maximum  number  of  iterations  that the eigensolver will
 perform  if  the  desired  tolerance  is  not  achieved.  The default is 25
 iterations  for  all  eigensolvers except for rmdiis, which performs only 3
 iterations (only increase it if you know what you are doing). 
END

Variable Output
Type flag
Default no
Section Output
Description
 Specifies  what  to  print.  The output files go into the static directory,
 except  when  running  a  time-dependent  simulation,  when  the  directory
 td.XXXXXXX  is used. For linear-response run modes, the derivatives of many
 quantities  can  be printed, as listed in the options below; the files will
 be  printed  in the directory for the run mode. Indices in the filename are
 labelled as follows: 
 sp  = spin, k = _k_-point, st = state/band, There is no tag for directions,
 given  as a letter. The perturbation direction is always the last direction
 for  linear-response  quantities, and a following +/- indicates the sign of
 the frequency. Example: density + potential 
Option potential 1
 Outputs  Kohn-Sham potential, separated by parts. File names are v0 for the
 local  part,  vc  for  the  classical  potential (if it exists), vh for the
 Hartree potential, and vxc- for the exchange-correlation potentials. 
Option density 2
 Outputs  density.  The  output  file  is called density-, or lr_density- in
 linear response. 
Option wfs 4
 Outputs  wavefunctions.  Which wavefunctions are to be printed is specified
 by the variable OutputWfsNumber -- see below. The output file is called 
 wf-, or lr_wf- in linear response. 
Option wfs_fourier 2097152
 (Experimental)  Outputs  wavefunctions  in  Fourier  space.  This  is  only
 implemented  for  the  ETSF  file  format  output.  The file will be called
 static/wfs-pw-etsf.nc. 
Option wfs_sqmod 8
 Outputs  modulus  squared  of  the wavefunctions. The output file is called
 sqm-wf-. For linear response, the filename is sqm_lr_wf-. 
Option geometry 16
 Outputs file containing the coordinates of the atoms treated within quantum
 mechanics.  If  OutputHow  =  xyz,  the file is called geometry.xyz; a file
 crystal.xyz is written with a supercell geometry if the system is periodic;
 if  point  charges  were defined in the PDB file (see PDBCoordinates), they
 will be output in the file geometry_classical.xyz. If OutputHow = xcrysden,
 a file called geometry.xsf is written. 
Option current 32
 Outputs  paramagnetic  current density. The output file is called current-.
 For linear response, the filename is lr_current-. 
Option ELF 64
 Outputs  electron  localization  function  (ELF). The output file is called
 elf-,  or lr_elf- in linear response, in which case the associated function
 D is also written, as lr_elf_D-. Only in 2D and 3D. 
Option ELF_basins 128
 Outputs basins of attraction of the ELF. The output file is called 
 elf_rs_basins.info. Only in 2D and 3D. 
Option ELF_FS 256
 Outputs electron localization function in Fourier space (experimental). The
 output file is called 
 elf_FS-. Only in 2D and 3D. 
Option Bader 512
 Outputs  Laplacian  of  the  density  which shows lone pairs, bonded charge
 concentrations and regions subject to electrophilic or nucleophilic attack.
 See  RF  Bader, _Atoms in Molecules: A Quantum Theory_ (Oxford Univ. Press,
 Oxford, 1990). 
Option el_pressure 1024
 Outputs electronic pressure. See Tao, Vignale, and Tokatly, _Phys Rev Lett_
 *100*, 206405 (2008). 
Option matrix_elements 2048
 Outputs a series of matrix elements of the Kohn-Sham states. What is output
 can be controlled by the OutputMatrixElements variable. 
Option pol_density 4096
 Outputs  dipole-moment  density  dipole_density-, or polarizability density
 alpha_density-  in linear response. If ResponseMethod = finite_differences,
 the hyperpolarizability density 
 beta_density- is also printed. 
Option mesh_r 8192
 Outputs values of the coordinates over the grid. Files will be in the exec/
 directory. 
Option kinetic_energy_density 16384
 Outputs kinetic-energy density, defined as: 

 \tau_\sigma(\vec{r})  =  \sum_{i=1}^{N_\sigma}  \vert  \nabla
 \phi_{i\sigma}(\vec{r}) \vert^2\,.  

 The  index  \sigma is the spin index for the spin-polarized case, or if you
 are  using  spinors.  For  spin-unpolarized calculations, you get the total
 kinetic-energy  density.  The  previous  expression  assumes  full  or null
 occupations.  If  fractional  occupation  numbers,  each term in the sum is
 weighted  by  the  occupation.  Also,  if  we  are working with an infinite
 system, all _k_-points are summed up, with their corresponding weights. The
 files  will  be  called  tau-sp1  and tau-sp2, if the spin-resolved kinetic
 energy  density  is  produced (runs in spin-polarized and spinors mode), or
 only tau if the run is in spin-unpolarized mode. 
Option dos 65536
 Outputs density of states. 
Option tpa 131072
 Outputs transition-potential approximation (TPA) matrix elements. 
Option density_matrix 262144
 Calculates,  and  outputs,  the  reduced density matrix. For the moment the
 trace is made over the second dimension, and the code is limited to 2D. The
 idea is to model _N_ particles in 1D as an 
 _N_-dimensional  non-interacting  problem,  then  to  trace  out  _N_-1
 coordinates. 
Option modelmb 524288
 This  flag  turns  on  the  output  for  model  many-body calculations, and
 triggers the density, wavefunctions, or density matrix to be output for the
 particles described in the DescribeParticlesModelMB block. Which quantities
 will be output depends on the simultaneous presence of wfs, 
 density, etc. 
Option forces 1048576
 Outputs  file  forces.xsf containing structure and forces on the atoms as a
 vector associated with each atom, which can be visualized with XCrySDen. 
END

Variable OutputWfsNumber
Type string
Default all states
Section Output
Description
 Which  wavefunctions  to  print,  in  list form: _i.e._, "1-5" to print the
 first  five  states, "2,3" to print the second and the third state, etc. If
 more states are specified than available, extra ones will be ignored. 
END

Variable CurrentThroughPlane
Type block
Section States
Description
 At  the  end  of  the  ground-state calculation, the code can calculate the
 steady-state  current in the ground state traversing a user-defined portion
 of  a  plane,  as specified by this block. In the format below, origin is a
 point in the plane. 
 u  and  v  are the (dimensionless) lattice vectors defining the plane; they
 will  be normalized by the code. spacing is the fineness of the mesh on the
 plane.  Integers  nu  and mu are the length and width of the portion of the
 plane, in units of spacing. Thus, the grid points included in the plane are
 
 x_ij  =  origin + i*spacing*u + j*spacing*v, for nu <= i <= mu  and nv <= j
 <=  mv. Analogously, in the 2D case, the current flow is calculated through
 a line; in the 1D case, the current flow is calculated through a point. 

 Example (3D): 

 %CurrentThroughPlane 
    0.0 | 0.0 | 0.0 # origin 
    0.0 | 1.0 | 0.0 # u 
    0.0 | 0.0 | 1.0 # v 
    0.2 # spacing 
    0 | 50 # nu | mu 
    -50 | 50 # nv | mv 
 % 

 Example (2D): 

 %CurrentThroughPlane 
    0.0 | 0.0 # origin 
    1.0 | 0.0 # u 
    0.2 # spacing 
    0 | 50 # nu | mu 
 % 

 Example (1D): 

 %CurrentThroughPlane 
    0.0 # origin 
 % 

END

Variable OutputEvery
Type integer
Default 50
Section Output
Description
 The output is saved when the iteration number is a multiple of the 
 OutputEvery  variable.  This  works for the ground-state and time-dependent
 runs. 
END

Variable OutputDuringSCF
Type logical
Default no
Section Output
Description
 If this variable is set to yes, during a ground-state run, 
 Octopus  output  will be written after every self-consistent iteration to a
 directory called scf.nnnn/ (with 
 nnnn the iteration number). 
END

Variable Displacement
Type float
Default 0.01 a.u.
Section Linear Response::Vibrational Modes
Description
 When calculating phonon properties by finite differences (CalculationMode =
 vib_modes, ResponseMethod = finite_differences ), 
 Displacement  controls  how  much  the  atoms  are  to be moved in order to
 calculate the dynamical matrix. 
END

Variable InvertKSTargetDensity
Type string
Default <tt>target_density.dat</tt>
Section Calculation Modes::Invert KS
Description
 Name  of  the  file  that  contains  the  density used as the target in the
 inversion of the KS equations. 
END

Variable CasidaKohnShamStates
Type string
Section Linear Response::Casida
Default all states
Description
 The  calculation  of  the  excitation  spectrum  of  a system in the Casida
 frequency-domain  formulation  of  linear-response  time-dependent  density
 functional  theory  (TDDFT)  implies  the  use  of  a  basis  set  of
 occupied/unoccupied  Kohn-Sham  orbitals.  This  basis  set  should,  in
 principle, include all pairs formed by all occupied states, and an infinite
 number  of  unoccupied  states. In practice, one has to truncate this basis
 set,  selecting  a  number of occupied and unoccupied states that will form
 the  pairs.  These  states  are specified with this variable. If there are,
 say,  15  occupied states, and one sets this variable to the value "10-18",
 this  means  that occupied states from 10 to 15, and unoccupied states from
 16 to 18 will be considered. 

 This  variable  is  a  string  in  list  form,  _i.e._  expressions such as
 "1,2-5,8-15"  are valid. You should include a non-zero number of unoccupied
 states and a non-zero number of occupied states. 
END

Variable CasidaTransitionDensities
Type string
Section Linear Response::Casida
Default write none
Description
 Specifies which transition densities are to be calculated and written down.
 The  transition  density  for  the many-body state _n_ will be written to a
 file called 
 casida/rho0n. 

 This  variable  is  a  string  in  list  form,  _i.e._  expressions such as
 "1,2-5,8-15" are valid. 
END

Variable CasidaMomentumTransfer
Type block
Section Linear Response::Casida
Default 0
Description
 Momentum-transfer  vector  for  the  calculation  of  the dynamic structure
 factor.  When  this  variable  is  set, the transition rates are determined
 using an exponential operator instead of the normal dipole one. 
END

Variable CasidaQuadratureOrder
Type integer
Section Linear Response::Casida
Default 5
Description
 Directionally  averaged dynamic structure factor is calculated by averaging
 over the results from a set of _q_-vectors. The vectors are generated using
 Gauss-Legendre  quadrature  scheme  [see  _e.g._  K. Atkinson, _J. Austral.
 Math.  Soc._  *23*,  332 (1982)], and this variable determines the order of
 the scheme. 
END

Variable GCMSlaterDeterminants
Type block
Section Calculation Modes::Generator Coordinates
Description

END

Variable UnoccMaximumIter
Type integer
Default 50
Section Calculation Modes::Unoccupied States
Description
 Maximum  number  of  eigensolver  iterations.  The  code  will stop even if
 convergence has not been achieved. -1 means unlimited. 
END

Variable NumberUnoccStates
Type integer
Default 5
Section Calculation Modes::Unoccupied States
Description
 How many unoccupied states to compute. 
END

Variable EMStaticElectricField
Type float
Default 0.01 a.u.
Section Linear Response::Static Polarization
Description
 Magnitude  of  the  static  electric  field  used  to  calculate the static
 polarizability, if ResponseMethod = finite_differences. 
END

Variable EMStartDensityIsZeroField
Type logical
Default true
Section Linear Response::Static Polarization
Description
 Use  the  charge  density  from  the zero-field calculation as the starting
 density  for  SCF  calculations with applied fields. For small fields, this
 will  be fastest. If there is trouble converging with larger fields, set to
 false,  to  initialize  the  calculation  for  each  field from scratch, as
 specified  by  the  LCAO  variables.  Only  applies  if  ResponseMethod  =
 finite_differences. 
END

Variable EMCalcDiagonalField
Type logical
Default true
Section Linear Response::Static Polarization
Description
 Calculate _yz_-field for beta__xyz_ hyperpolarizability, which is sometimes
 harder to converge. Only applies if ResponseMethod = finite_differences. 
END

Variable EMWriteRestartDensities
Type logical
Default true
Section Linear Response::Static Polarization
Description
 Write  density  after  each  calculation  for restart, rather than just the
 resulting  electronic  dipole  moment.  Only  applies  if  ResponseMethod =
 finite_differences.  Restarting  from calculations at smaller fields can be
 helpful if there are convergence problems. 
END

Variable EMVerbose
Type logical
Default false
Section Linear Response::Static Polarization
Description
 Write full SCF output. Only applies if ResponseMethod = finite_differences.
 
END

Variable TestMode
Type integer
Default hartree_test
Section Utilities::oct-test
Description
 Decides what kind of test should be performed. 
Option hartree_test 1
 Tests the various Hartree solvers. 
Option derivatives 2
 Tests  the  implementation  of  the  finite-difference  operators,  used to
 calculate derivatives. 
Option orthogonalization 3
 Tests the implementation of the orthogonalization routines. 
Option subspace_diag 4
 Tests the implementation of the subspace diagonalization routine. 
END

Variable TestType
Type integer
Default all
Section Utilities::oct-test
Description
 Decides what on what type of values the test should be performed. 
Option real 1
 Tests derivatives for real functions. 
Option complex 2
 Tests derivatives for complex functions. 
Option all 3
 Tests derivatives for both real and complex functions. 
END

Variable FromScratch
Type logical
Default false
Section Execution
Description
 When  this variable is set to true, Octopus will perform a calculation from
 the beginning, without looking for restart information. 
END

Variable ResponseMethod
Type integer
Default sternheimer
Section Linear Response
Description
 Some  response  properties  can be calculated either via Sternheimer linear
 response  or  by  using  finite  differences.  You can use this variable to
 select  how  you  want  them  to  be  calculated, it applies to em_resp and
 vib_modes  calculation  modes.  By default, the Sternheimer linear-response
 technique is used. 
Option sternheimer 1
 The  linear  response  is obtained by solving a self-consistent Sternheimer
 equation for the variation of the orbitals. This is the recommended method.
 
Option finite_differences 2
 Properties  are calculated as a finite-differences derivative of the energy
 obtained  by  several  ground-state  calculations.  This  method,  slow and
 limited  only  to  static response, is kept mainly because it is simple and
 useful for testing purposes. 
END

Variable ReportMemory
Type logical
Default no
Section Execution::Debug
Description
 If  true, Octopus will print as part of the screen output information about
 the  memory the code is using. The quantity reported is an approximation to
 the size of the heap and generally it is a lower bound to the actual memory
 Octopus is using. By default this variable is set to false. 
END

Variable CalculationMode
Type integer
Default gs
Section Calculation Modes
Description
 Decides what kind of calculation is to be performed. 
Option gs 01
 Calculation of the ground state. 
Option unocc 02
 Calculation of unoccupied/virtual KS states. 
Option td 03
 Time-dependent calculation (experimental for periodic systems). 
Option go 05
 Optimization of the geometry. 
Option opt_control 07
 Optimal control. 
Option em_resp 08
 Calculation  of the electromagnetic response: electric polarizabilities and
 hyperpolarizabilities  and  magnetic  susceptibilities  (experimental  for
 periodic systems). 
Option casida 09
 Excitations via Casida linear-response TDDFT; for finite systems only. 
Option td_transport 10
 Time-dependent quantum transport (experimental). 
Option vdw 11
 Calculate van der Waals coefficients. 
Option vib_modes 12
 Calculation of the vibrational modes. 
Option one_shot 14
 Use  the self-consistent wavefunctions in the restart directory to evaluate
 the  total  energy  using  a different XC functional. This is effectively a
 first-order  perturbative calculation of the total energy, the perturbation
 being the difference between the two XC potentials used. 
Option kdotp 15
 Calculation  of  effective  masses  by  _k.p_  perturbation  theory
 (experimental). 
Option gcm 16
 Generator-Coordinates calculation (experimental). 
Option memory 17
 Estimate the amount of memory Octopus will need to run. 
Option invert_ks 18
 Invert the Kohn-Sham equations (experimental). 
Option recipe 99
 Prints out a tasty recipe. 

 May  also  be  used  as a block for multi-dataset mode. The first line is a
 list  of  calculation modes, the second is labels (optional), and the third
 is the order for the runs (optional). Example: 

 %CalculationMode gs | unocc | td "run1" | "run2" 1 | 2 | 3 % 
END

Variable GOMethod
Type integer
Default steep
Section Calculation Modes::Geometry Optimization
Description
 Method by which the minimization is performed. 
Option steep 1
 Simple steepest descent. 
Option cg_fr 2
 Fletcher-Reeves  conjugate-gradient  algorithm.  The  conjugate-gradient
 algorithm  proceeds  as a succession of line minimizations. The sequence of
 search  directions is used to build up an approximation to the curvature of
 the function in the neighborhood of the minimum. 
Option cg_pr 3
 Polak-Ribiere conjugate-gradient algorithm. 
Option cg_bfgs 4
 Vector  Broyden-Fletcher-Goldfarb-Shanno  (BFGS)  conjugate-gradient
 algorithm.  It is a quasi-Newton method which builds up an approximation to
 the  second  derivatives  of  the function _f_ using the difference between
 successive gradient vectors. By combining the first and second derivatives,
 the  algorithm  is  able  to  take  Newton-type  steps towards the function
 minimum, assuming quadratic behavior in that region. 
Option cg_bfgs2 5
 The  bfgs2  version  of  this  minimizer  is  the  most  efficient  version
 available, and is a faithful implementation of the line minimization scheme
 described  in  Fletcher,  _Practical  Methods  of Optimization_, Algorithms
 2.6.2 and 2.6.4. 
Option simplex 6
 This  is  experimental, and in fact, *not* recommended unless you just want
 to  fool around. It is the Nead-Melder simplex algorithm, as implemented in
 the  GNU  Scientific  Library  (GSL). It does not make use of the gradients
 (_i.e._, the forces) which makes it more inefficient than other schemes. It
 is included here for completeness, since it is free. 
END

Variable GOTolerance
Type float
Default 0.001 a.u.
Section Calculation Modes::Geometry Optimization
Description
 Convergence  criterion,  for  stopping the minimization. In units of force;
 minimization  is  stopped  when  all  forces  on ions are smaller than this
 criterion. Used in conjunction with GOMinimumMove. If GOTolerance = 0, this
 criterion is ignored. The default is 0.001 H/b (0.5 eV/Angstrom). 
END

Variable GOMinimumMove
Type float
Default 0.0 a.u.
Section Calculation Modes::Geometry Optimization
Description
 Convergence  criterion,  for stopping the minimization. In units of length;
 minimization  is  stopped  when  the coordinates of all species change less
 than GOMinimumMove. Used in conjunction with GOTolerance. If 
 GOMinimumMove = 0, this criterion is ignored. The default is 0. 

 Note that if you use GOMethod = simplex, then you must supply a non-zero 
 GOMinimumMove. 
END

Variable GOStep
Type float
Default 0.5
Section Calculation Modes::Geometry Optimization
Description
 Initial step for the geometry optimizer. WARNING: in some weird units. 
END

Variable GOMaxIter
Type integer
Default 200
Section Calculation Modes::Geometry Optimization
Description
 Even  if  the convergence criterion is not satisfied, the minimization will
 stop after this number of iterations. 
END

Variable GOObjective
Type integer
Default minimize_energy
Section Calculation Modes::Geometry Optimization
Description
 This  rather  esoteric option allows one to choose which objective function
 to  minimize  during  a geometry minimization. The use of this variable may
 lead to inconsistencies, so please make sure you know what you are doing! 
Option minimize_energy 1
 Use the total energy as objective function. 
Option minimize_forces 2
 Use  \sqrt{\sum  |f_i|^2} as objective function. Note that in this case one
 still  uses  the forces as the gradient of the objective function. This is,
 of course, inconsistent, and may lead to very strange behavior. 
END

Variable TDPropagator
Type integer
Default etrs
Section Time-Dependent::Propagation
Description
 This  variable  determines  which algorithm will be used to approximate the
 evolution operator U(t+\delta t, t). That is, given 
 \psi(\tau)  and  H(\tau)  for tau \le t, calculate t+\delta t. Note that in
 general  the  Hamiltonian  is  not  known  at  times in the interior of the
 interval  [t,t+\delta  t]. This is due to the self-consistent nature of the
 time-dependent  Kohn-Sham  problem: the Hamiltonian at a given time \tau is
 built from the "solution" wavefunctions at that time. 

 Some  methods, however, do require the knowledge of the Hamiltonian at some
 point  of the interval [t,t+\delta t]. This problem is solved by making use
 of extrapolation: given a number l of time steps previous to time 
 t,  this  information  is  used to build the Hamiltonian at arbitrary times
 within [t,t+\delta t]. To be fully precise, one should then proceed 
 _self-consistently_:  the  obtained Hamiltonian at time t+\delta t may then
 be  used to interpolate the Hamiltonian, and repeat the evolution algorithm
 with this new information. Whenever iterating the procedure does not change
 the  solution  wavefunctions, the cycle is stopped. In practice, in Octopus
 we  perform  a second-order extrapolation without a self-consistency check,
 except  for  the first two iterations, where obviously the extrapolation is
 not reliable. 

 The  proliferation  of methods is certainly excessive. The reason for it is
 that  the propagation algorithm is currently a topic of active development.
 We  hope  that in the future the optimal schemes are clearly identified. In
 the mean time, if you do not feel like testing, use the default choices and
 make sure the time step is small enough. 
Option etrs 2
 The idea is to make use of time-reversal symmetry from the beginning: 

 <MATH>  \exp  \left(-i\delta t/2 H_{n}\right)\psi_n = exp \left(i\delta t/2
 H_{n+1}\right)\psi_{n+1}, 
 </MATH> 

 and then invert to obtain: 

 <MATH>  \psi_{n+1}  =  \exp  \left(-i\delta  t/2  H_{n+1}\right)  exp
 \left(-i\delta t/2 H_{n}\right)\psi_{n}. 
 </MATH> 

 But  we  need  to know H_{n+1}, which can only be known exactly through the
 solution 
 \psi_{n+1}.  What  we  do  is  to  estimate  it  by  performing  a  single
 exponential: 
 \psi^{*}_{n+1}=\exp \left( -i\delta t H_{n} \right) \psi_n, and then 
 H_{n+1}  =  H[\psi^{*}_{n+1}].  Thus  no extrapolation is performed in this
 case. 
Option aetrs 3
 Approximated  Enforced  Time-Reversal  Symmetry  (AETRS). A modification of
 previous  method  to  make  it  faster. It is based on extrapolation of the
 time-dependent potentials. It is faster by about 40%. 

 The  only  difference  is the procedure to estimate @math{H_{n+1}}: in this
 case  it is extrapolated via a second-order polynomial by making use of the
 Hamiltonian at time @math{t-2\delta t}, @math{t-\delta t} and @math{t}. 
Option caetrs 12
 (experimental)  Corrected  Approximated  Enforced  Time-Reversal  Symmetry
 (AETRS), this is the previous propagator but including a correction step to
 the exponential. 
Option exp_mid 4
 Exponential  Midpoint  Rule (EM). This is maybe the simplest method, but it
 is  very  well grounded theoretically: it is unitary (if the exponential is
 performed  correctly)  and  preserves  time-reversal  symmetry  (if  the
 self-consistency problem is dealt with correctly). It is defined as: 

 <MATH>  U_{\rm  EM}(t+\delta  t,  t)  =  \exp \left( -i\delta t H_{t+\delta
 t/2}\right)\,. 
 </MATH> 
Option crank_nicholson 5
 Classical Crank-Nicholson propagator. 

 <MATH> (1 + i\delta t/2 H_{n+1/2}) \psi_{n+1} = (1 - i\delta t/2 H_{n+1/2})
 \psi_{n} 
 </MATH> 
Option crank_nicholson_sparskit 6
 Classical Crank-Nicholson propagator. Requires the SPARSKIT library. 

 <MATH> (1 + i\delta t/2 H_{n+1/2}) \psi_{n+1} = (1 - i\delta t/2 H_{n+1/2})
 \psi_{n} 
 </MATH> 
Option magnus 7
 Magnus  Expansion  (M4).  This  is the most sophisticated approach. It is a
 fourth-order  scheme  (a  feature  which  it shares with the ST scheme; the
 other schemes are in principle second-order). It is tailored for making use
 of  very  large time steps, or equivalently, dealing with problem with very
 high-frequency time-dependence. It is still in a experimental state; we are
 not yet sure of when it is advantageous. 
Option crank_nicholson_src_mem 8
 Crank-Nicholson  propagator  with  source  and  memory  term  for transport
 calculations. 
Option qoct_tddft_propagator 10
 WARNING: EXPERIMENTAL 
Option qoct_tddft_propagator_2 11
 WARNING: EXPERIMENTAL 
END

Variable TDStepsWithSelfConsistency
Type integer
Default 3
Section Time-Dependent::Propagation
Description
 Since  the  KS  propagator  is  non-linear, each propagation step should be
 performed  self-consistently.  In  practice,  for most purposes this is not
 necessary,  except perhaps in the first iterations. This variable holds the
 number  of  propagation  steps  for  which  the  propagation  is  done
 self-consistently. 

 The  special  value  all_steps forces self-consistency to be imposed on all
 propagation  steps.  A  value  of 0 means that self-consistency will not be
 imposed.  The  default  is  3,  which  means  that self-consistency is only
 enforced during the first three steps. 
Option all_steps -1
 Self-consistency is imposed for all propagation steps. 
END

Variable TDOutput
Type flag
Default multipoles + geometry + temperature + energy
Section Time-Dependent::TD Output
Description
 Defines what should be output during the time-dependent simulation. 
Option multipoles 1
 Outputs  the  multipole  moments  of  the  density  to  the  file
 td.general/multipoles.  This  is  required  to,  _e.g._,  calculate optical
 absorption  spectra  of  finite  systems. The maximum value of l can be set
 with the variable TDDipoleLmax. 
Option angular 2
 Outputs  the  angular  momentum of the system that can be used to calculate
 circular dichroism (EXPERIMENTAL). 
Option spin 4
 Outputs  the  expectation  value of the spin, that can be used to calculate
 magnetic cicular dichroism (EXPERIMENTAL). 
Option populations 8
 Outputs  the  projection of the time-dependent Kohn-Sham Slater determinant
 onto the ground-state (or approximations to the excited states) to the file
 
 td.general/populations. 
Option geometry 16
 If  set  (and  if  the atoms are allowed to move), outputs the coordinates,
 velocities, and forces of the atoms to the the file td.general/coordinates.
 
Option acceleration 32
 When  set,  outputs the acceleration, calculated from Ehrenfest theorem, in
 the  file  td.general/acceleration.  This file can then be processed by the
 utility hs-from-acc in order to obtain the harmonic spectrum. 
Option laser 64
 If set, and if there are lasers defined in TDLasers, 
 octopus outputs the laser field to the file td.general/laser. 
Option energy 128
 If  set, octopus outputs the different components of the energy to the file
 td.general/el_energy. 
Option td_occup 256
 If  set,  outputs  the  projections  of  the  time-dependent  Kohn-Sham
 wavefunctions  onto  the  static  (zero-time)  wavefunctions  to  the  file
 td.general/projections.XXX. 
Option local_mag_moments 512
 If  set,  outputs the local magnetic moments, integrated in sphere centered
 around  each  atom.  The  radius  of  the  sphere  can  be  set  with
 LocalMagneticMomentsSphereRadius. 
Option gauge_field 1024
 If set, outputs the vector gauge field corresponding to a spatially uniform
 (but  time-dependent) external electrical potential. This is only useful in
 a time-dependent periodic run. 
Option temperature 2048
 If set, the ionic temperature at each step is printed. 
Option ftchd       4096
 Write Fourier transform of the electron density to the file ftchds.X, where
 X  depends  on the kick (e.g. with sin-shaped perturbation X=qsin). This is
 needed  for  calculating the dynamic structure factor. In the case that the
 kick  mode  is  qbessel,  the  written  quantity  is integral over density,
 multiplied by spherical Bessel function times real spherical harmonic. 
Option velocity    8192
 When  set,  outputs the velocity, calculated from Ehrenfest theorem, in the
 file  td.general/velocity.  This  file can then be processed by the utility
 hs-from-vel in order to obtain the harmonic spectrum. 
END

Variable TDDipoleLmax
Type integer
Default 1
Section Time-Dependent::TD Output
Description
 Maximum  multipole  of the density output to the file td.general/multipoles
 during a time-dependent simulation. Must be 0 &lt; TDDipoleLmax &lt; 5. 
END

Variable TDProjStateStart
Type integer
Default 1
Section Time-Dependent::TD Output
Description
 Only  output  projections  to states above TDProjStateStart. Usually one is
 only  interested  in particle-hole projections around the HOMO, so there is
 no  need to calculate (and store) the projections of all TD states onto all
 static  states.  This  sets  a  lower  limit. The upper limit is set by the
 number  of  states  in  the propagation and the number of unoccupied states
 available. 
END

Variable TDExcitedStatesToProject
Type block
Section Time-Dependent::TD Output
Description
 *[WARNING:  This  is  a *very* experimental feature]* The population of the
 excited  states  (as  defined  by  <Phi_I|Phi(t)>  where  |Phi(t)>  is  the
 many-body  time-dependent  state  at  time  _t_, and |Phi_I> is the excited
 state  of  interest)  can be approximated -- it is not clear how well -- by
 substituting  for  those real many-body states the time-dependent Kohn-Sham
 determinant and some modification of the Kohn-Sham ground-state determinant
 (_e.g._,  a simple HOMO-LUMO substitution, or the Casida ansatz for excited
 states  in  linear-response  theory.  If  you  set  TDOutput  to  contain
 populations, you may ask for these approximated populations for a number of
 excited  states,  which  will  be  described in the files specified in this
 block:  each  line  should  be the name of a file that contains one excited
 state. 

 FIXME: description of the format of the files. 
END

Variable MemoryTol
Type float
Default 1e-12
Section Time-Dependent::Open Boundaries
Description
 Decides when to consider the memory coefficients converged. 
END

Variable MemoryMaxIter
Type integer
Default 500
Section Time-Dependent::Open Boundaries
Description
 Sets the maximum iteration number to converge the memory coefficients. 
END

Variable TransformStates
Type block
Default no
Section States
Description
 Before  starting the td calculation, the initial states (that are read from
 the  restart/gs  directory,  which should have been generated in a previous
 ground-state  calculation) can be "transformed" among themselves. The block
 TransformStates  gives  the transformation matrix to be used. The number of
 rows  of  the  matrix  should equal the number of the states present in the
 time-dependent  calculation  (the  independent spin and _k_-point subspaces
 are  all transformed equally); the number of columns should be equal to the
 number of states present in the 
 restart/gs  directory. This number may be different: for example, one could
 have  run  previously in unocc mode in order to obtain unoccupied Kohn-Sham
 states, and therefore restart/gs will contain more states. These states can
 be used in the transformation. 

 Note that the code will not check the orthonormality of the new states! 

 Each  line provides the coefficients of the new states, in terms of the old
 ones. 
END

Variable TDFreezeOrbitals
Type integer
Default 0
Section Time-Dependent
Description
 You  have  the  possibility  of  "freezing"  a  number of orbitals during a
 time-propagation.  The  Hartree  and  exchange-correlation potential due to
 these  orbitals (which will be the lowest-energy ones) will be added during
 the propagation, but the orbitals will not be propagated. 

 *WARNING: NOT TESTED YET.* 
Option sae -1
 Single-active-electron  approximation.  This  option  is  only  valid  for
 time-dependent calculations (CalculationMode = td). Also, the nuclei should
 not move. The idea is that all orbitals except the last one are frozen. The
 orbitals  are  to  be  read  from  a previous ground-state calculation. The
 active  orbital  is then treated as independent (whether if it contains one
 electron  or  two)  --  although  it  will  feel  the  Hartree  and
 exchange-correlation  potentials  from  the  ground-state  electronic
 configuration. 

 It  is  almost equivalent to setting TDFreezeOrbitals = N-1, where N is the
 number of orbitals, but not completely. 
END

Variable PhotoElectronSpectrumPoints
Type block
Section Time-Dependent::PhotoElectronSpectrum
Description
 List  of  points at which to calculate the photoelectron spectrum by Suraud
 method. The exact syntax is: 

 %PhotoElectronSpectrumPoints 
   x1 | y1 | z1 
 % 
  
END

Variable TDIonicTimeScale
Type float
Default 1.0
Section Time-Dependent::Propagation
Description
 This  variable  defines  the  factor  between  the  timescale  of ionic and
 electronic  movement.  It  allows  reasonably  fast  Born-Oppenheimer
 molecular-dynamics  simulations  based  on Ehrenfest dynamics. The value of
 this  variable  is  equivalent  to  the  role  of  \mu  in  Car-Parrinello.
 Increasing  it  linearly accelerates the time step of the ion dynamics, but
 also  increases  the  deviation  of  the  system  from the Born-Oppenheimer
 surface.  The  default is 1, which means that both timescales are the same.
 Note  that  a  value  different  than 1 implies that the electrons will not
 follow physical behaviour. 

 According to our tests, values around 10 are reasonable, but it will depend
 on your system, mainly on the width of the gap. 

 Important: The electronic time step will be the value of 
 TDTimeStep  divided  by this variable, so if you have determined an optimal
 electronic  time  step (that we can call _dte_), it is recommended that you
 define your time step as: 

 TDTimeStep = _dte_ * TDIonicTimeScale 

 so you will always use the optimal electronic time step. 

 For more details see: http://arxiv.org/abs/0710.3321 

END

Variable TDTimeStep
Type float
Section Time-Dependent::Propagation
Description
 The  time-step  for  the time propagation. For most propagators you want to
 use  the  largest  value  that  is  possible without the evolution becoming
 unstable. 

 The  default value is the maximum value that we have found empirically that
 is  stable  for  the  spacing  Octopus is using. However, you might need to
 adjust this value. 
END

Variable TDMaximumIter
Type integer
Default 1500
Section Time-Dependent::Propagation
Description
 Number of time-propagation steps that will be performed. By default 1500. 

 Tip:  If you would like to specify the real time of the propagation, rather
 than the number of steps, just use something like: 

 TDMaximumIter = 1000.0 / TDTimeStep 

END

Variable TDDynamics
Type integer
Default ehrenfest
Section Time-Dependent::Propagation
Description
 Type  of  dynamics  to  follow  during a time propagation. By default it is
 Ehrenfest TDDFT. 
Option ehrenfest 1
 Ehrenfest dynamics. 
Option bo 2
 Born-Oppenheimer (Experimental). 
Option cp 3
 Car-Parrinello molecular dynamics. 
END

Variable RecalculateGSDuringEvolution
Type logical
Default no
Section Time-Dependent::Propagation
Description
 In order to calculate some information about the system along the evolution
 (e.g.  projection  onto  the ground-state KS determinant, projection of the
 TDKS  spin-orbitals  onto  the  ground-state  KS  spin-orbitals),  the
 ground-state KS orbitals are needed. If the ionic potential changes -- that
 is,  the ions move -- one may want to recalculate the ground state. You may
 do this by setting this variable. 

 The  recalculation  is not done every time step, but only every OutputEvery
 time steps. 
END

Variable TDEnergyUpdateIter
Type integer
Default 10
Section Time-Dependent::Propagation
Description
 This  variable controls how often Octopus updates the total energy during a
 time  propagation  run.  The default is every 10 iterations. For iterations
 where  the energy is not updated, the last calculated value is reported. If
 you set this variable to 1, the energy will be calculated in each step. 
END

Variable OpenBoundariesQMRMaxIter
Type integer
Default 100
Section Open Boundaries
Description
 Sets  the  maximum  iteration  number  for  the  QMR  linear  solver in the
 Crank-Nicholson procedure for open boundaries. 
END

Variable OpenBoundariesQMRTol
Type integer
Default 1e-12
Section Open Boundaries
Description
 Sets  the convergence tolerance for the residue in the QMR linear solver in
 the Crank-Nicholson procedure. 
END

Variable OpenBoundariesMemType
Type integer
Default save_cpu_time
Section Open Boundaries
Description
 Decides whether the memory coefficients use lots of RAM (default) or uses a
 more compact scheme but with the need of more CPU-cycles. 

Option save_cpu_time 1
 Use the memory-intensive procedure 
Option save_ram_usage 2
 Use the RAM-saving, CPU-intensive procedure 
END

Variable OpenBoundariesAdditionalTerms
Type flag
Default mem_term + src_term
Section Open Boundaries
Description
 The  open-boundaries  propagator  inserts  two  additional  terms  in  the
 Crank-Nicholson  scheme: source and memory. With this variable, one or both
 of them can be switched off. 

Option mem_term 1
 If present, include memory term in propagator 
Option src_term 2
 If present, include source term in propagator 
END

Variable OpenBoundariesMaxMemCoeffs
Type integer
Default TDMaximumIter
Section Open Boundaries
Description
 Sets  the  maximum  number  of  used  memory  coefficients.  Can be used to
 pre-calculate memory coefficients. 
END

Variable PropagationSpectrumType
Type integer
Default AbsorptionSpectrum
Section Utilities::oct-propagation_spectrum
Description
 Type of spectrum to calculate. 
Option AbsorptionSpectrum 1
 Photoabsorption spectrum. 
Option EnergyLossSpectrum 2
 Dynamic structure factor (also known as energy-loss function or spectrum). 
END

Variable PropagationSpectrumDampMode
Type integer
Default polynomial
Section Utilities::oct-propagation_spectrum
Description
 Decides  which  damping/filtering  is  to  be applied in order to calculate
 spectra by calculating a Fourier transform. 
Option no 0
 No filtering at all. 
Option exponential 1
 Exponential filtering, corresponding to a Lorentzian-shaped spectrum. 
Option polynomial 2
 Third-order polynomial damping. 
Option gaussian 3
 Gaussian damping. 
END

Variable PropagationSpectrumTransform
Type integer
Default sine
Section Utilities::oct-propagation_spectrum
Description
 Decides which transform to perform. 
Option sine 2
 Sine transform \int dt \sin(wt) f(t) 
Option cosine 3
 Cosine transform \int dt \cos(wt) f(t) 
Option exponential 1
 Exponential transform \int dt \exp(-wt) f(t) 
END

Variable PropagationSpectrumStartTime
Type float
Default 0.0
Section Utilities::oct-propagation_spectrum
Description
 Processing  is  done for the given function in a time-window that starts at
 the value of this variable. 
END

Variable PropagationSpectrumEndTime
Type float
Default -1.0 au
Section Utilities::oct-propagation_spectrum
Description
 Processing is done for the given function in a time-window that ends at the
 value  of this variable. If set to a negative value, the maximum value from
 the corresponding multipole file will used. 
END

Variable PropagationSpectrumEnergyStep
Type float
Default 0.01 eV
Section Utilities::oct-propagation_spectrum
Description
 Sampling rate for the spectrum. 
END

Variable PropagationSpectrumMaxEnergy
Type float
Default 20 eV
Section Utilities::oct-propagation_spectrum
Description
 The Fourier transform is calculated for energies smaller than this value. 
END

Variable PropagationSpectrumDampFactor
Type float
Default 0.15 au
Section Utilities::oct-propagation_spectrum
Description
 If  PropagationSpectrumDampMode = exponential, the damping parameter of the
 exponential is fixed through this variable. 
END

Variable TDDeltaStrength
Type float
Default 0
Section Time-Dependent::Response
Description
 When  no  laser  is  applied,  a delta (in time) perturbation with strength
 TDDeltaStrength  can  be  applied.  This  is used to calculate, _e.g._, the
 linear  optical  spectra.  If  the  ions are allowed to move, the kick will
 affect them also. The electric field is -(\hbar _k_ / _e_) delta(_t_) for a
 dipole  with zero wavevector, where _k_ = TDDeltaStrength, which causes the
 wavefunctions  instantaneously  to  acquire a phase exp(_ikx_). The unit is
 inverse length. 
END

Variable TDDeltaStrengthMode
Type integer
Default kick_density
Section Time-Dependent::Response
Description
 When  calculating the density response via real-time propagation, one needs
 to  perform  an  initial  kick on the KS system, at time zero. Depending on
 what  kind  of response property one wants to obtain, this kick may be done
 in several modes. 
Option kick_density 0
 The total density of the system is perturbed. 
Option kick_spin 1
 The  individual  spin  densities  are perturbed differently. Note that this
 mode  is  only  possible if the run is done in spin-polarized mode, or with
 spinors. 
Option kick_spin_and_density 2
 A combination of the two above. Note that this mode is only possible if the
 run is done in spin-polarized mode, or with spinors. 
END

Variable TDKickFunction
Type block
Section Time-Dependent::Response
Description
 If the block TDKickFunction is present in the input file, the kick function
 to  be  applied at time zero of the time-propagation will not be a "dipole"
 function  (_i.e._  phi  =>  exp(i*k*z) phi), but a general multipole in the
 form r^l * Y_{lm}(r). 

 Each  line has two columns of integers: the (_l_,_m_) pair that defines the
 multipole.  Any  number of lines may be given, and the kick will be the sum
 of those multipoles. 

 This  feature  allows  calculation  of quadrupole, octupole, etc., response
 functions. 
END

Variable TDPolarizationEquivAxes
Type integer
Default 0
Section Time-Dependent::Response
Description
 Defines  how  many  of  the  TDPolarization  axes  are  equivalent.  This
 information  is  stored in a file and then used by oct-propagation_spectrum
 to  rebuild  the  full  polarizability  tensor  from  just  the  first
 TDPolarizationEquivAxes  directions.  This  variable  is  also  used  by
 CalculationMode = vdw. 
END

Variable TDPolarizationDirection
Type integer
Default 1
Section Time-Dependent::Response
Description
 When  a  delta potential is included in a time-dependent run, this variable
 defines  in  which  direction the field will be applied by selecting one of
 the lines of TDPolarization. In a typical run (without using symmetry), the
 TDPolarization  block  would  contain the three Cartesian unit vectors (the
 default value), and one would make 3 runs varying 
 TDPolarization from 1 to 3. 

END

Variable TDPolarization
Type block
Section Time-Dependent::Response
Description
 The  (real)  polarization  of  the delta electric field. Normally one needs
 three perpendicular polarization directions to calculate a spectrum (unless
 symmetry is used). The format of the block is: 

 %TDPolarization 
   pol1x | pol1y | pol1z 
   pol2x | pol2y | pol2z 
   pol3x | pol3y | pol3z 
 % 

 Octopus uses both this block and the variable 
 TDPolarizationDirection  to  determine the polarization vector for the run.
 For example, if 
 TDPolarizationDirection=2  the  polarization (pol2x, pol2y, pol2z) would be
 used. 

 The  default  value  for TDPolarization is the three Cartesian unit vectors
 (1,0,0), (0,1,0), and (0,0,1). 

 WARNING: If you want to obtain the cross-section tensor, the 
 TDPolarization  block  must  be  exactly  the  same  for  the  run  in each
 direction. The direction must be selected by the 
 TDPolarizationDirection variable. 

END

Variable TDPolarizationWprime
Type block
Section Time-Dependent::Response
Description
 Say  you  have a first symmetry operation _A_ that takes you from the first
 axis _p1_ to the second axis _p2_, and then a second symmetry operation _B_
 that  takes  you  from  the  second  axis  _p2_  to  the  third  _p3_. Then
 TDPolarizationWprime = _A_^{-1} _p3_. 
END

Variable TDMomentumTransfer
Type block
Section Time-Dependent::Response
Description
 Momentum-transfer  vector  for  the  calculation  of  the dynamic structure
 factor.  When  this  variable is set, a non-dipole field is applied, and an
 output file 
 ftchd  is  created (it contains the Fourier transform of the charge density
 at  each  time).  The  type  of the applied external field can be set by an
 optional last number. Possible options are qexp (default), qcos, 
 qsin, or qcos+qsin. 
Option qexp 1
 External field is exp(_iq.r_). 
Option qcos 2
 External field is cos(_q.r_). 
Option qsin 3
 External field is sin(_q.r_). 
Option qbessel 4
 External  field  is  j_l(qr)*Y_lm(r),  where  q  is  the  length  of  the
 momentum-transfer  vector.  In this case the block has to include two extra
 values (l and m). 
END

Variable PESMaskSpectEnergyMax
Type float
Section Time-Dependent::PES
Description
 The maximum energy for the PES spectrum (default 30 a.u.). 
END

Variable PESMaskSpectEnergyStep
Type float
Section Time-Dependent::PES
Description
 The PES spectrum energy step (default 0.05 a.u.). 
END

Variable CPElectronicMass
Type float
Default 1.0
Section Time-Dependent::Propagation
Description
 The  fictitious  electronic  mass  used  to  propagate  the  electronic
 wavefunctions in the Car-Parrinello formalism. 
END

Variable CPMethod
Type integer
Default verlet
Section Time-Dependent::Propagation
Description
 This  variable  defines  how to integrate the Car-Parrinello equations. The
 default is verlet. 
Option verlet 2
 Standard Verlet. 
Option vel_verlet 1
 RATTLE/Velocity Verlet integrator. 
END

Variable PhotoElectronSpectrum
Type flag
Default no
Section Time-Dependent::PhotoElectronSpectrum
Description
This variable controls the method used for the calculation of
the photoelectron spectrum. You can specify more than one value
by giving them as a sum, for example:
 PhotoElectronSpectrum = pes_rc + pes_mask 
Option none 0
 The photoelectron spectrum is not calculated. This is the default. 
Option pes_rc 2
 Store  the  wavefunctions  at  specific  points  in  order to calculate the
 photoelectron  spectrum  at  a point far in the box as proposed in A. Pohl,
 P.-G. Reinhard, and E. Suraud, _Phys. Rev. Lett._ *84*, 5090 (2000). 
Option pes_mask 4
 Calculate  the  photo-electron spectrum using the mask method. (D. Varsano,
 PhD thesis, page 159 (2006) http://nano-bio.ehu.es/files/varsano_phd.pdf). 

 For  this  to work, masking boundaries are necessary (AbsorbingBoundaries =
 mask). 
END

Variable RestartWrite
Type logical
Default true
Section Execution::IO
Description
 If  this  variable  is  set  to no, restart information is not written. The
 default is yes. 
END

Variable RestartDir
Type string
Default ''
Section Execution::IO
Description
 When  Octopus  reads  restart  files,  e.g. when running a time-propagation
 after a ground-state calculation, these files will be read from 
 &lt;RestartDir&gt/. Usually, RestartDir is 
 TmpDir  but in a transport calculation, the output of a periodic dataset is
 required to calculate the extended ground state. 
END

Variable UserDefinedStates
Type block
Section States
Description
 Instead of using the ground state as initial state for time-propagations it
 might  be  interesting in some cases to specify alternate states. Like with
 user-defined  potentials, this block allows you to specify formulas for the
 orbitals at _t_=0. 

 Example: 

 %UserDefinedStates 
    1 | 1 | 1 | formula | "exp(-r^2)*exp(-i*0.2*x)" | normalize_yes 
 % 

 The  first  column specifies the component of the spinor, the second column
 the  number  of the state and the third contains _k_-point and spin quantum
 numbers.  Column four indicates that column five should be interpreted as a
 formula for the corresponding orbital. 

 Alternatively,  if  column four states file the state will be read from the
 file given in column five. 

 %UserDefinedStates 
    1 | 1 | 1 | file | "/path/to/file" | normalize_no 
 % 

 Octopus  reads  first  the  ground-state  orbitals  from  the  restart/gs
 directory.  Only  the  states that are specified in the above block will be
 overwritten with the given analytic expression for the orbital. 

 The  sixth  (optional)  column indicates whether Octopus should renormalize
 the orbital. The default (no sixth column given) is to renormalize. 

Option file 0
 Read initial orbital from file. 
Option formula 1
 Calculate initial orbital by given analytic expression. 
Option normalize_yes 1
 Normalize orbitals (default). 
Option normalize_no 0
 Do not normalize orbitals. 
END

Variable NDimModelmb
Type integer
Section States
Default -1
Description
 Number  of  dimensions  for  modelmb  space.  Full  Ndim  =
 NDimModelmb*NParticleModelmb 

END

Variable NParticleModelmb
Type integer
Section States
Default 0
Description
 Number  of  particles  in  modelmb  space.  Full  Ndim  =
 NDimModelmb*NParticleModelmb 
END

Variable NTypeParticleModelmb
Type integer
Section States
Default 1
Description
 Number of different types of particles in modelmb space. 
END

Variable DescribeParticlesModelmb
Type block
Section States
Description
 Characterization  of  different  modelmb  particles  in  gr%mesh%sb%dim
 dimensional space. 

 %DescribeParticlesModelmb 
    proton | 1 | 1800. | 1. | fermion 
    proton | 1 | 1800. | 1. | fermion 
    electron | 2 | 1. | 1. | fermion 
 % 

 would  tell  Octopus  that  there are presently 3 particles, called proton,
 proton,  and electron, with types 1, 1, and 2, and corresponding masses and
 charges.  All  particles should be fermions, and this can be later enforced
 on  the  spatial  part  of  the  wavefunctions.  The  label  and charge are
 presently  only  for  informational purposes and are not checked or used in
 Octopus. The interaction has to take the actual charge into account. 

Option fermion 1
 Particle is a fermion. 
Option boson 2
 Particle is a boson. 
Option anyon 3
 Particle is neither fermion nor boson. 
END

Variable DensitiestoCalc
Type block
Section States
Description
 Choice  of  which  particle densities will be calculated and output, in the
 modelmb particles scheme. 

 %DensitiestoCalc 
    proton | 1 
    electron | 2 
 % 

 would  ask  Octopus  to  calculate  the  density  corresponding  to the 1st
 particle  (whose  coordinates  correspond  to dimensions 1 to NDimModelmb),
 which  is  an  electron,  then  that  corresponding  to  the  2nd  particle
 (dimensions NDimModelmb+1 to 2*NDimModelmb). 
END

Variable DensityMatricestoCalc
Type block
Section States
Description
 choice of which particle density matrices will be calculated and output, in
 the modelmb particles scheme (the corresponding density is also output) 

 %DensityMatricestoCalc 
    proton | 1 | 10 
    electron | 2 | 15 
 % 

 would  ask octopus to calculate the density matrix corresponding to the 1st
 particle  (whose  coordinates  correspond to dimensions 1 to ndim_modelmb),
 which  is  an proton, then that corresponding to the 2nd particle (electron
 with  dimensions  ndim_modelmb+1  to  2*ndim_modelmb),  printing 10 natural
 orbitals for the first and 15 for the second. 

END

Variable DegeneracyThreshold
Type float
Default 1e-5
Section States
Description
 A  state  j with energy E_j will be considered degenerate with a state with
 energy E_i, if E_i - threshold < E_j < E_i + threshold. 
END

Variable SpinComponents
Type integer
Default unpolarized
Section States
Description
 The  calculations  may  be  done  in  three different ways: spin-restricted
 (TD)DFT  (_i.e._,  doubly  occupied  "closed shells"), spin-unrestricted or
 "spin-polarized"  (TD)DFT  (_i.e._ we have two electronic systems, one with
 spin up and one with spin down), or making use of two-component spinors. 
Option unpolarized 1
 Spin-restricted calculations. 
Option polarized 2
Option spin_polarized 2
 Spin  unrestricted, also known as spin-DFT, SDFT. This mode will double the
 number of wavefunctions necessary for a spin-unpolarized calculation. 
Option non_collinear 3
Option spinors 3
 The  spin-orbitals  are  two-component spinors. This effectively allows the
 spin-density  to  be  oriented  non-collinearly:  _i.e._  the magnetization
 vector  is  allowed  to take different directions at different points. This
 vector is always in 3D regardless of Dimensions. 
END

Variable ExcessCharge
Type float
Default 0.0
Section States
Description
 The  net  charge  of  the system. A negative value means that we are adding
 electrons,  while  a  positive value means we are taking electrons from the
 system. 
END

Variable TotalStates
Type integer
Default 0
Section States
Description
 This  variable  sets the total number of states that Octopus will use. This
 is  normally  not  necessary  since  by  default Octopus sets the number of
 states  to  the  minimum  necessary  to  hold  the electrons present in the
 system. (This default behavior is obtained by setting TotalStates to 0). 

 If  you  want to add some unoccupied states, probably it is more convenient
 to use the variable 
 ExtraStates. 

 Note that this number is unrelated to CalculationMode == unocc. 
END

Variable ExtraStates
Type integer
Default 0
Section States
Description
 The  number  of  states  is in principle calculated considering the minimum
 numbers  of  states  necessary to hold the electrons present in the system.
 The number of electrons is in turn calculated considering the nature of the
 species supplied in the 
 Species block, and the value of the ExcessCharge variable. However, one may
 command  Octopus to use more states, which is necessary if one wants to use
 fractional  occupational  numbers,  either fixed from the beginning through
 the  Occupations  block  or  by  prescribing an electronic temperature with
 Smearing. 

 Note that this number is unrelated to CalculationMode == unocc. 
 ExtraStates  is  used  for  a  self-consistent  calculation  and  the usual
 convergence  criteria  on  the  density  do  not  take  into  account  the
 eigenvalues,  whereas  unocc  is  a  non-self-consistent  calculation,  and
 explicitly  considers  the  eigenvalues  of  the  unoccupied  states as the
 convergence criteria. 
END

Variable CurrentDFT
Type logical
Default false
Section Hamiltonian
Description
 (experimental)  If  set  to  yes,  Current-DFT  will  be  used. This is the
 extension  to  DFT  that  should  be used when external magnetic fields are
 present. The current-dependent part of the XC functional is set using the 
 JFunctional variable. The default is no. 
END

Variable OnlyUserDefinedInitialStates
Type logical
Default no
Section States
Description
 If  true,  then  only  user-defined states from the block UserDefinedStates
 will  be  used as initial states for a time-propagation. No attempt is made
 to load ground-state orbitals from a previous ground-state run. 
END

Variable CurrentInTau
Type logical
Default yes
Section States
Description
 If  true,  a term including the (paramagnetic or total) current is included
 in the calculation of the kinetic-energy density. 
END

Variable SymmetrizeDensity
Type logical
Default no
Section States
Description
 When  enabled  the density is symmetrized. Currently, this can only be done
 for periodic systems. 

 It  is  enabled  by  default when symmetries are used to reduce the k-point
 grid (KPointsUseSymmetries = yes), otherwise it is disabled by default. 
END

Variable Occupations
Type block
Section States
Description
 The occupation numbers of the orbitals can be fixed through the use of this
 variable. For example: 

 %Occupations 
   2.0 | 2.0 | 2.0 | 2.0 | 2.0 
 % 

 would fix the occupations of the five states to _2.0_. There can be at most
 as  many  columns  as states in the calculation. If there are fewer columns
 than  states,  then  the  code  will assume that the user is indicating the
 occupations  of  the uppermost states, assigning maximum occupation (i.e. 2
 for  spin-unpolarized  calculations,  1  otherwise) to the lower states. If
 SpinComponents  ==  polarized  this block should contain two lines, one for
 each  spin  channel.  This variable is very useful when dealing with highly
 symmetric  small systems (like an open-shell atom), for it allows us to fix
 the  occupation  numbers  of  degenerate states in order to help octopus to
 converge.  This  is to be used in conjuction with ExtraStates. For example,
 to calculate the carbon atom, one would do: 

 ExtraStates = 2 
 %Occupations 
   2 | 2/3 | 2/3 | 2/3 
 % 

 If  you want the calculation to be spin-polarized (which makes more sense),
 you could do: 

 ExtraStates = 2 
 %Occupations 
    2/3 | 2/3 | 2/3 
    0 | 0 | 0 
 % 

 Note  that  in this case the first state is absent, the code will calculate
 four  states  (two  because  there  are  four  electrons,  plus two because
 ExtraStates = 2), and since it finds only three columns, it will occupy the
 first state with one electron for each of the spin options. 

 If  the  sum  of  occupations  is  not  equal  to  the  total charge set by
 ExcessCharge,  an error message is printed. If FromScratch = no, this block
 is  ignored  when restart information is read, and the previous occupations
 are used. 
END

Variable InitialSpins
Type block
Section States
Description
 The  spin  character  of  the initial random guesses for the spinors can be
 fixed  by  making  use of this block. Note that this will not "fix" the the
 spins during the calculation (this cannot be done in spinors mode, in being
 able  to  change  the  spins  is  why  the spinors mode exists in the first
 place). 

 This  block  is  meaningless  and ignored if the run is not in spinors mode
 (SpinComponents = spinors). 

 The structure of the block is very simple: each column contains the desired
 &lt;_S_x_&gt;,  &lt;_S_y_&gt;,  &lt;_S_z_&gt;  for  each  spinor.  If  the
 calculation  is for a periodic system and there is more than one _k_-point,
 the spins of all the _k_-points are the same. 

 For  example,  if  we  have two spinors, and we want one in the _Sx_ "down"
 state, and another one in the _Sx_ "up" state: 

 %InitialSpins 
    0.5 | 0.0 | 0.0 
    -0.5 | 0.0 | 0.0 
 % 

 WARNING:  if  the calculation is for a system described by pseudopotentials
 (as  opposed  to  user-defined potentials or model systems), this option is
 meaningless  since  the  random  spinors  are  overwritten  by  the  atomic
 orbitals. 

 There are a couple of physical constraints that have to be fulfilled: 

 (A) | &lt;_S_i_&gt; | &lt;= 1/2 

 (B) &lt;_S_x_&gt;^2 + &lt;_S_y_&gt;^2 + &lt;_S_z_&gt;^2 = 1/4 

END

Variable ForceComplex
Type logical
Default no
Section Execution::Debug
Description
 Normally  Octopus  determines  automatically  the  type  necessary  for the
 wavefunctions.  When set to yes this variable will force the use of complex
 wavefunctions. 

 Warning:  This variable is designed for testing and benchmarking and normal
 users need not use it. 

END

Variable StatesBlockSize
Type integer
Default max(4, 2*nthreads)
Section Execution::Optimization
Description
 Some  routines work over blocks of eigenfunctions, which generally improves
 performance  at  the expense of increased memory consumption. This variable
 selects the size of the blocks to be used. 
END

Variable StatesOrthogonalization
Type integer
Default gram_schmidt
Section Execution::Optimization
Description
 The full orthogonalization method used by some eigensolvers. The default is
 gram_schmidt. When state parallelization the default is par_gram_schmidt. 
Option gram_schmidt 1
 The  standard Gram-Schmidt orthogonalization implemented using BLAS/LAPACK.
 Can be used with domain parallelization but not state parallelization. 
Option par_gram_schmidt 2
 The  standard  Gram-Schmidt  orthogonalization implemented using ScaLAPACK.
 Compatible with states parallelization. 
Option mgs 3
 Modified Gram-Schmidt orthogonalization. 
Option qr 4
 (Experimental)  Orthogonalization  is performed based on a QR decomposition
 based  on  Lapack  routines  _getrf  and  _orgqr.  Compatible  with  states
 parallelization. 
Option old_gram_schmidt 5
 Old Gram-Schmidt implementation, compatible with states parallelization. 
END

Variable OutputBandsGnuplotMode
Type logical
Default no
Section Output
Description
 The  band  file  will be written in Gnuplot-friendly format to bands-gp.dat
 (or band-gp-is.dat if spin-polarized). 
END

Variable OutputBandsGraceMode
Type logical
Default no
Section Output
Description
 The  band  file will be written in Grace-friendly format to bands-grace.dat
 (or bands-grace-is.dat if spin-polarized). 
END

Variable MomentumTransfer
Type block
Section States
Description
 Momentum-transfer  vector  _q_  to be used when calculating matrix elements
 &lt;f|exp(iq.r)|i&gt;.  This  enables  the  calculation  of  the  dynamical
 structure  factor,  which  is  closely  related  to  generalized oscillator
 strengths.  If the vector is not given, but TPA output is requested (Output
 =  TPA),  only the oscillator strengths are written in the output file. For
 example, to use _q_ = (0.1, 0.2, 0.3), set 

 %MomentumTransfer 
    0.1 | 0.2 | 0.3 
 % 
END

Variable DOSEnergyMin
Type float
Section Output
Description
 Lower  bound  for  the  energy  mesh  of the DOS. The default is the lowest
 eigenvalue, minus a quarter of the total range of eigenvalues. 
END

Variable DOSEnergyMax
Type float
Section Output
Description
 Upper  bound  for  the  energy  mesh of the DOS. The default is the highest
 eigenvalue, plus a quarter of the total range of eigenvalues. 
END

Variable DOSEnergyPoints
Type integer
Default 500
Section Output
Description
 Determines  how  many  energy  points Octopus should use for the DOS energy
 grid. 
END

Variable DOSGamma
Type float
Default 0.008 Ha
Section Output
Description
 Determines the width of the Lorentzian which is used for the DOS sum. 
END

Variable SmearingFunction
Type integer
Default semiconducting
Section States
Description
 This  is  the  function  used  to  smear  the electronic occupations. It is
 ignored if the Occupations block is set. 
Option semiconducting 1
 Semiconducting  occupations,  _i.e._  the  lowest lying states are occupied
 until no more electrons are left. 
Option fermi_dirac 2
 Simple  Fermi-Dirac distribution. In this case, Smearing has the meaning of
 an electronic temperature. DN Mermin, _Phys. Rev._ *137*, A1441 (1965). 
Option cold_smearing 3
 N  Marzari, D Vanderbilt, A De Vita, and MC Payne, _Phys. Rev. Lett._ *82*,
 3296 (1999). 
Option methfessel_paxton 4
 M Methfessel and AT Paxton, _Phys. Rev. B_ *40*, 3616 (1989). In this case,
 the  variable  SmearingMPOrder  sets the order of the smearing. Occupations
 may be negative. 
Option spline_smearing 5
 Nearly  identical  to  Gaussian smearing. JM Holender, MJ Gillan, MC Payne,
 and AD Simpson, _Phys. Rev. B_ *52*, 967 (1995). 
END

Variable Smearing
Type float
Default 0.1 eV
Section States
Description
 If  Occupations  is  not  set,  Smearing  is the smearing width used in the
 SmearingFunction to distribute the electrons among the existing states. 
END

Variable SmearingMPOrder
Type integer
Default 1
Section States
Description
 Sets the order of the Methfessel-Paxton smearing function. 
END

Variable MeshBlockSize
Type block
Section Execution::Optimization
Description
 To improve memory-access locality when calculating derivatives, 
 Octopus  arranges mesh points in blocks. This variable controls the size of
 this  blocks in the different directions. The default is | 20 | 20 | 100 |.
 (This  variable  only  affects  the  performance  of  Octopus  and  not the
 results.) 
END

Variable MeshPartitionFromScratch
Type logical
Default false
Section Execution::Parallelization
Description
 If  set to no (the default) Octopus will try to use the mesh partition from
 a previous run if available. 
END

Variable MeshUseTopology
Type logical
Default false
Section Execution::Parallelization
Description
 (experimental)  If enabled, Octopus will use an MPI virtual topology to map
 the  processors.  This  can improve performance for certain interconnection
 systems. 
END

Variable MultigridLevels
Type integer
Default 0
Section Mesh
Description
 Number of levels in the grid hierarchy used for multigrid. Positive numbers
 indicate  an  absolute number of levels, negative numbers are subtracted to
 maximum  number  of  levels possible for the grid been used. Default is the
 maximum number of levels for the grid. 
Option max_levels 0
 Calculate the optimal number of levels for the grid. 
END

Variable OpenBoundaries
Type block
Section Mesh
Description
 This  feature is experimental. In transport mode it enables open boundaries
 in the _x_-direction and defines the character of the leads attached to the
 left  and  right  of  the finite central system. The more general situation
 (non-transport) is that a given number of leads (number_leads) are attached
 to the central region. 

 The format is as follows: 

 <pre> %OpenBoundaries lead_dataset | "dataset" | "dataset" lead_restart_dir
 |  "directory"  |  "directory"  lead_static_dir | "directory" | "directory"
 add_unit_cells  |  nl  |  nr  td_pot_formula  |  "formula"  |  "formula"
 transport_mode | transport_on number_leads | 2 % 
 </pre> 

 The  left  column  specifies  characteristics  of the left lead and and the
 right  column  characteristics  of  the right lead analogously. If only one
 column is given, the value specified is used for both leads. 

 All entries except lead_dataset are optional. 

Option lead_dataset 1
 Gives  the  name  of  the  dataset used for the periodic calculation of the
 ground  states of the leads. It is used, _e.g._, to read in the coordinates
 of the atoms of the lead. Both entries for left and right have to be equal.
 
Option lead_restart_dir 2
 lead_restart_dir  gives  the  name  of  restart  directory  of the periodic
 ground-state  calculation  for  the  lead  unit  cell.  Though one may give
 different  datasets  for the left and right lead, they have to be identical
 due  to  the  algorithm used to obtain extended eigenstates. The default is
 &lt;lead_dataset&gt;restart. 
Option lead_static_dir 3
 The same as lead_restart_dir for the static directory. 
 Octopus needs the Kohn-Sham potential of the leads. Therefore, the periodic
 run  must include Output = potential in the input file. The default of this
 entry is &lt;lead_dataset&gt;static. 
Option add_unit_cells 4
 add_unit_cells specifies how many lead unit cells should be included in the
 computational  domain.  Suitable  values  highly depend on the system under
 study  but  the  numbers  nl  and  nr  should be taken large enough for the
 potential to equilibrate because we assume instaneous metallic screening in
 the  leads.  Furthermore,  note  that  in  a  ground-state calculation, one
 additional  unit  cell  is  added  automatically  for  each  lead  to  the
 computational  domain because the propagation algorithm needs the knowledge
 of the initial state for the first unit cell outside the simulation box. If
 omitted,  no  unit  cells are included in the simulation region (apart from
 the one which is automatically added in ground-state calculations). 
Option td_pot_formula 5
 Defines  a  spatially  local  time-dependent  potential  in the leads as an
 analytic expression. This describes the time-dependent bias in the leads. 
Option transport_mode 6
 If  set  to  on  (transport_on)  the  normal transport calculation is done,
 otherwise  (transport_off)  an  open  system  without  the source term. The
 initial  state  is  to be assumed to be completely localized in the central
 region. Default is transport_on. 
Option number_leads 7
 In  the  non-transport mode it defines the number of leads connected to the
 central region. 

Option transport_on 1
 Use transport (default). 
Option transport_off 0
 Just use open boundaries. 
END

Variable MeshPartitionPackage
Type integer
Default metis
Section Execution::Parallelization
Description
 Decides  which  library  to  use to perform the mesh partition. By default,
 METIS is used (if available). 
Option metis 2
 METIS library. 
Option zoltan 3
 Zoltan library. 
Option ga 4
 (Experimental) Genetic-algorithm optimization of the grid partition. 
END

Variable MeshPartitionStencil
Type integer
Default star
Section Execution::Parallelization
Description
 To  partition  the  mesh, it is necessary to calculate the connection graph
 connecting  the  points.  This variable selects which stencil is used to do
 this. The default is the order-one star stencil. Alternatively, the stencil
 used for the Laplacian may be used. 
Option stencil_star 1
 An order-one star stencil. 
Option laplacian 2
 The stencil used for the Laplacian is used to calculate the partition. This
 in  principle should give a better partition, but it is slower and requires
 more memory. 
END

Variable DoubleGrid
Type logical
Default no
Section Mesh
Description
 Enables  or  disables  the  use  of a double-grid technique to increase the
 precision of the application of the pseudopotentials. 
END

Variable DoubleGridOrder
Type integer
Default 9
Section Mesh
Description
 Order of the interpolation used for the double grid. Must be an odd number.
 Low-order  interpolation schemes are not recommended. The default is to use
 9th-order interpolation. 
END

Variable CurvMethod
Type integer
Default curv_uniform
Section Mesh::Curvilinear
Description
 The  relevant functions in octopus are represented on a mesh in real space.
 This mesh may be an evenly spaced regular rectangular grid (standard mode),
 or  else  an  *adaptive*  or  *curvilinear grid*. We have implemented three
 kinds  of  adaptive meshes, although only one is currently working, the one
 invented by F. Gygi (curv_gygi). The code will stop if any of the other two
 is invoked. 
Option curv_uniform 1
 Regular, uniform rectangular grid. The default. 
Option curv_gygi 2
 The deformation of the grid is done according to the scheme described by F.
 Gygi [F. Gygi and G. Galli, _Phys. Rev. B_ *52*, R2229 (1995)]. 
Option curv_briggs 3
 The  deformation  of  the grid is done according to the scheme described by
 Briggs  [E.L.  Briggs,  D.J. Sullivan, and J. Bernholc, _Phys. Rev. B_ *54*
 14362 (1996)] (NOT WORKING). 
Option curv_modine 4
 The  deformation  of  the grid is done according to the scheme described by
 Modine  [N.A. Modine, G. Zumbach and E. Kaxiras, _Phys. Rev. B_ *55*, 10289
 (1997)] (NOT WORKING). 
END

Variable UseFineMesh
Type logical
Default no
Section Mesh
Description
 If enabled, Octopus will use a finer mesh for the calculation of the forces
 or other sensitive quantities. The default is no. 
END

Variable Spacing
Type float
Section Mesh
Description
 The  spacing  between  the  points  in  the  mesh.  If  using  curvilinear
 coordinates,  this  is  a canonical spacing that will be changed locally by
 the transformation. 

 It  is  possible  to  have a different spacing in each one of the Cartesian
 directions if we define Spacing as block of the form 

 %Spacing 
   spacing_x | spacing_y | spacing_z 
 % 
END

Variable CurvGygiA
Type float
Section Mesh::Curvilinear::Gygi
Description
 The  grid spacing is reduced locally around each atom, and the reduction is
 given  by 1/(1+A), where A is specified by this variable, CurvGygiA. So, if
 A=1/2 (the default), the grid spacing is reduced to two thirds = 1/(1+1/2).
 [This  is  the A_{\alpha} variable in Eq. 2 of F. Gygi and G. Galli, _Phys.
 Rev. B_ *52*, R2229 (1995)] It must be larger than zero. 
END

Variable CurvGygiAlpha
Type float
Section Mesh::Curvilinear::Gygi
Description
 This number determines the region over which the grid is enhanced (range of
 enhancement  of  the resolution). That is, the grid is enhanced on a sphere
 around  each  atom,  whose  radius  is given by this variable. [This is the
 a_{\alpha} variable in Eq. 2 of F. Gygi and G. Galli, _Phys. Rev. B_ *52M*,
 R2229  (1995)].  The  default  is  two atomic units. It must be larger than
 zero. 
END

Variable CurvGygiBeta
Type float
Section Mesh::Curvilinear::Gygi
Description
 This  number  determines  the distance over which Euclidean coordinates are
 recovered.  [This  is  the  b_{\alpha}  variable in Eq. 2 of F. Gygi and G.
 Galli, 
 _Phys.  Rev.  B_  *52*, R2229 (1995)]. The default is four atomic units. It
 must be larger than zero. 
END

Variable DerivativesStencil
Type integer
Default stencil_star
Section Mesh::Derivatives
Description
 Decides  what  kind  of  stencil  is used, _i.e._ which points, around each
 point in the mesh, are the neighboring points used in the expression of the
 differential operator. 

 If  curvilinear  coordinates are to be used, then only the stencil_starplus
 or  the  stencil_cube  may be used. We only recommend the stencil_starplus,
 since the cube typically needs way too much memory resources. 
Option stencil_star 1
 A star around each point (_i.e._, only points on the axis). 
Option stencil_variational 2
 Same as the star, but with coefficients built in a different way. 
Option stencil_cube 3
 A cube of points around each point. 
Option stencil_starplus 4
 The star, plus a number of off-axis points. 
END

Variable DerivativesOrder
Type integer
Default 4
Section Mesh::Derivatives
Description
 This  variable  gives the discretization order for the approximation of the
 differential operators. This means, basically, that 
 DerivativesOrder  points  are  used  in  each  positive/negative  spatial
 direction,  _e.g._  DerivativesOrder  =  1  would  give  the  well-known
 three-point  formula  in  1D.  The  number  of points actually used for the
 Laplacian depends on the stencil used: 

 stencil_star: 2*DerivativesOrder*_dim_+1 

 stencil_cube: (2*DerivativesOrder+1)^_dim_ 

 stencil_starplus:  2*DerivativesOrder+1+_n_  with _n_ being 12 in 2D and 44
 in 3D. 
END

Variable ParallelizationOfDerivatives
Type integer
Default non_blocking
Section Execution::Parallelization
Description
 This option selects how the communication of mesh boundaries is performed. 
Option blocking 1
 Blocking communication. 
Option non_blocking 2
 Communication  is  based on non-blocking point-to-point communication. This
 is the default. 
END

Variable MeshPartition
Type integer
Section Execution::Parallelization
Description
 Decides which algorithm is used to partition the mesh. By default, 
 graph partitioning is used for 8 or more partitions, and rcb for fewer. 
Option rcb 2
 Recursive coordinate bisection partitioning. 
Option rib 3
 Recursive inertial bisection partitioning. 
Option hsfc 4
 Hilbert space-filling curve partioning. 
Option reftree 5
 Refinement-tree-based partitioning. 
Option graph 6
 Graph partitioning. 
Option hypergraph 7
 Hypergraph partitioning. 
END

Variable OperateDouble
Type integer
Default autodetect
Section Execution::Optimization
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid for real functions. By default the optimized version is used. 
Option fortran 0
 The standard Fortran function. 
Option optimized 1
 This version is optimized using vector primitives (if available). 
END

Variable OperateComplex
Type integer
Default autodetect
Section Execution::Optimization
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid for complex functions. By default the optimized version is used. 
Option fortran 0
 The standard Fortran function. 
Option optimized 1
 This version is optimized using vector primitives (if available). 
END

Variable OperateOpenCL
Type integer
Default autodetect
Section Execution::Optimization
Description
 This variable selects the subroutine used to apply non-local operators over
 the grid when opencl is used. The default is map. 
Option invmap 1
 The standard implementation ported to OpenCL. 
Option map 2
 A different version, more suitable for GPUs. 
END

Variable FFTLibrary
Type logical
Section Hamiltonian::Poisson
Default fftw
Description
 (experimental) You can select the FFT library to use. 
Option fftw 0
 Uses FFTW3 library. 
Option pfft 1
 (experimental) Uses PFFT library, which has to be linked. 
END

Variable OutputHow
Type flag
Default 0
Section Output
Description
 Describes  the  format  of the output files (see Output). Example: axis_x +
 plane_x + dx 
Option axis_x 1
 The values of the function on the _x_ axis are printed. The string .y=0,z=0
 is appended to previous file names. 
Option axis_y 2
 The values of the function on the _y_ axis are printed. The string .x=0,z=0
 is appended to previous file names. 
Option axis_z 4
 The values of the function on the _z_ axis are printed. The string .x=0,y=0
 is appended to previous file names. 
Option plane_x 8
 A  plane  slice  at  _x_  =  0  is  printed. The string .x=0 is appended to
 previous file names. 
Option plane_y 16
 A  plane  slice  at  _y_  =  0  is  printed. The string .y=0 is appended to
 previous file names. 
Option plane_z 32
 A  plane  slice  at  _z_  =  0  is  printed. The string .z=0 is appended to
 previous file names. 
Option dx 64
 For  printing  three-dimensional  information,  the  open-source  program
 visualization tool OpenDX (http://www.opendx.org/) can be used. The string 
 .dx is appended to previous file names. 
Option netcdf 128
 Outputs  in  NetCDF  (http://www.unidata.ucar.edu/packages/netcdf/) format.
 This  file  can  then  be read, for example, by OpenDX. The string .ncdf is
 appended to previous file names. Requires the NetCDF library. 
Option mesh_index 512
 Generates  output  files  of a given quantity (density, wavefunctions, ...)
 which  include  the  internal  numbering  of  mesh  points. Since this mode
 produces large datafiles this is only useful for small meshes and debugging
 purposes.  The  output  can  also  be  used to display the mesh directly. A
 Gnuplot  script  for  mesh  vizualization  can  be  found  under
 PREFIX/share/octopus/util/display_mesh_index.gp. 
Option xcrysden 1024
 A  format  for printing structures and three-dimensional information, which
 can  be  visualized  by  the  free  open-source  program  XCrySDen
 (http://www.xcrysden.org/). The string 
 .xsf  is  appended  to  previous  file names. Note that lattice vectors and
 coordinates are as specified by UnitsOutput. 
Option matlab 2048
 In combination with plane_x, plane_y and 
 plane_z, this option produces output files which are suitable for 2D Matlab
 functions like mesh(), 
 surf(), or waterfall(). To load these files into Matlab you can use, _e.g._
 
<tt>
 >> density = load('static/density-1.x=0.matlab.abs'); >> mesh(density); 
</tt>
Option meshgrid 4096
 Outputs in Matlab mode the internal mesh in a format similar to 
<tt>
 >> [x,y] = meshgrid(-2:.2:2,-1:.15:1) 
</tt>
 The  _x_  meshgrid is contained in a file *.meshgrid.x and the _y_-grid can
 be found in 
 *.meshgrid.y. 
Option boundary_points 8192
 This  option  includes  the  output  of  the  mesh  enlargement. Default is
 without. 
Option binary 16384
 Plain binary, new format. 
Option etsf 32768
 ETSF  file  format
 (http://www.etsf.eu/resources/software/standardization_project).  Requires
 the ETSF_IO library. 
Option xyz 65536
 Geometry will be output in XYZ format. Does not affect other outputs. 
Option cube 131072
 Generates  output  in  the  cube  file  format
 (http://local.wasp.uwa.edu.au/~pbourke/dataformats/cube/) 
END

Variable MeshPartitionGAPopulation
Type integer
Default 30
Section Execution::Parallelization
Description
 The  size of the population used for the genetic algorithm used to optimize
 the mesh partition. The default is 30. 
END

Variable MeshPartitionGAMaxSteps
Type integer
Default 1000
Section Execution::Parallelization
Description
 The  number  of  steps performed for the genetic algorithm used to optimize
 the mesh partition. The default is 1000. 
END

Variable TDExternalFields
Type block
Section Time-Dependent
Description
 The  block  TDExternalFields describes the type and shape of time-dependent
 external perturbations that are applied to the system. 

 Each  line  of  the  block  describes  an  external field; this way you can
 actually have more than one laser (_e.g._ a "pump" and a "probe"). 

 The syntax of each line is: 

 %TDExternalField 
    type | ...other descriptors... 
 % 

 The  first  element  of each line describes which kind of external field is
 described  by  the  line:  (i)  an  electric field (electric_field); (ii) a
 magnetic  field  (magnetic_field);  (iii)  a  vector  potential
 (vector_potential)  --  this  option,  in  the  current version, is a field
 constant in space, which permits us to describe an electric perturbation in
 the velocity gauge; (iv) an arbitrary scalar potential (scalar_potential). 

 The  "other  descriptors"  depend  on which kind of external field has been
 indicated in the first column. 

 (A) type = electric field, magnetic field, vector_potential 

 For these cases, the syntax is: 

 %TDExternalFields 
    type | nx | ny | nz | omega | envelope_function_name 
 % 

 The  three  (possibly  complex)  numbers  (_nx_,  _ny_,  _nz_)  mark  the
 polarization  direction  of  the field. The float omega will be the carrier
 frequency  of  the  pulse.  The  envelope  of the field is a time-dependent
 function  whose  definition  must  be  given  in  a  TDFunctions  block.
 envelope_function_name  is a string (and therefore it must be surrounded by
 quotation  marks)  that  must  match one of the function names given in the
 first column of the TDFunctions block. 

 (B) type = scalar_potential 

 %TDExternalFields 
    scalar_potential | "scalar_expression" | freq | envelope_function_name 
 % 

 The  scalar potential is not just a dipole, but any expression given by the
 string  "scalar_expression".  The  temporal  shape  is  determined  by  the
 envelope function defined by envelope_function_name. 

 A NOTE ON UNITS: 

 It  is  very  common  to  describe  the  strength  of  a laser field by its
 intensity,  rather than using the electric-field amplitude. In atomic units
 (or,  more  precisely,  in  any Gaussian system of units), the relationship
 between instantaneous electric field and intensity is: 
  I(t) = \frac{c}{8\pi} E^2(t) . 

 It  is  common to read intensities in W/cm^2. The dimensions of intensities
 are  [W]/(L^2T),  where  [W]  are  the  dimensions  of energy. The relevant
 conversion factors are: 

  Hartree / (a_0^2 atomic_time) = 6.4364086e+15 W / cm^2  

  eV / ( angstrom^2 (hbar/eV) ) = 2.4341348e+12 W / cm^2  

 If,  in  atomic units, we set the electric-field amplitude to E_0, then the
 intensity is: 

  I_0 = 3.51 10^16 W/cm^2 (E_0^2)  

 If, working with "Units = ev_angstrom", we set E_0, then the intensity is: 

  I_0 = 1.327 10^13 (E_0^2) W/cm^2  

Option electric_field 1
 The  external  field  is  an electric field, the usual case when we want to
 describe a laser in the length gauge. 
Option magnetic_field 2
 The external field is a (homogeneous) time-dependent magnetic field. 
Option vector_potential 3
 The  external field is a time-dependent homogeneous vector potential, which
 may describe a laser field in the velocity gauge. 
Option scalar_potential 4
 The  external field is an arbitrary scalar potential, which may describe an
 inhomogeneous electrical field. 
END

Variable FilterPotentials
Type integer
Default filter_none
Section Hamiltonian
Description
 Octopus  can  filter  the  pseudopotentials  so that they no longer contain
 Fourier  components  larger  than  the  mesh itself. This is very useful to
 decrease  the  egg-box effect, and so should be used in all instances where
 atoms move. 
Option filter_none 1
 Do not filter. 
Option filter_TS 2
 The  filter  of M. Tafipolsky and R. Schmid, _J. Chem. Phys._ *124*, 174102
 (2006). 
Option filter_BSB 3
 The filter of E. L. Briggs, D. J. Sullivan, and J. Bernholc, _Phys. Rev. B_
 *54*, 14362 (1996). 
END

Variable ClassicalPotential
Type integer
Default 0
Section Hamiltonian
Description
 Whether and how to add to the external potential the potential generated by
 the classical charges read from the PDB input (see PBDCoordinates). 
Option no 0
 No classical charges. 
Option point_charges 1
 Classical charges are treated as point charges. 
Option gaussian_smeared 2
 Classical  charges  are  treated as Gaussian distributions. Smearing widths
 are hard-coded by species (experimental). 
END

Variable StaticElectricField
Type block
Section Hamiltonian
Description
 A  static constant electric field may be added to the usual Hamiltonian, by
 setting the block StaticElectricField. The three possible components of the
 block  (which  should  only  have one line) are the three components of the
 electric field vector. It can be applied in a periodic direction of a large
 supercell via the single-point Berry phase. 
END

Variable StaticMagneticField
Type block
Section Hamiltonian
Description
 A  static constant magnetic field may be added to the usual Hamiltonian, by
 setting the block StaticMagneticField. The three possible components of the
 block  (which  should  only  have one line) are the three components of the
 magnetic  field  vector.  Note that if you are running the code in 1D mode,
 this will not work, and if you are running the code in 2D mode the magnetic
 field  will  have to be in the _z_-direction, so that the first two columns
 should be zero. 

 The  magnetic field should always be entered in atomic units, regardless of
 the  Units variable. Note that we use the "Gaussian" system meaning 1 au[B]
 = 1.7152553 * 10^7 gauss, which corresponds to 1.7152553 * 10^3 Tesla. 
END

Variable StaticMagneticField2DGauge
Type integer
Default 0
Section Hamiltonian
Description
 The  gauge  of  the  static  vector  potential  A when a magnetic field B =
 (0,0,B_z) is applied onto a 2D-system. 
Option linear_xy 0
 Linear gauge with A = ((1/2)/P_c)*(-y,x)*B_z. This is the default. 
Option linear_y 1
 Linear gauge with A = (1/P_c)*(-y,0)*B_z 
END

Variable GyromagneticRatio
Type float
Default 2.0023193043768
Section Hamiltonian
Description
 The  gyromagnetic  ratio  of  the  electron.  This  is of course a physical
 constant, and the default value is the exact one that you should not touch,
 unless  :  (i)  You  want  to  disconnect  the anomalous Zeeman term in the
 Hamiltonian (then set it to zero; this number only affects that term); (ii)
 You are using an effective Hamiltonian, as is the case when you calculate a
 2D  electron  gas,  in which case you have an effective gyromagnetic factor
 that depends on the material. 
END

Variable RelativisticCorrection
Type integer
Default non_relativistic
Section Hamiltonian
Description
 The  default  value  means  that  _no_  relativistic correction is used. To
 include spin-orbit coupling turn RelativisticCorrection to spin_orbit (this
 will  only  work  if  SpinComponents  has  been set to non_collinear, which
 ensures the use of spinors). 
Option non_relativistic 0
 No relativistic corrections. 
Option spin_orbit 1
 Spin-orbit. 
END

Variable SOStrength
Type float
Default 1
Section Hamiltonian
Description
 Tuning  of  the  spin-orbit  coupling  strength: setting this value to zero
 turns  off  spin-orbit  terms  in  the  Hamiltonian,  and setting it to one
 corresponds to full spin-orbit. 
END

Variable IgnoreExternalIons
Type logical
Default no
Section Hamiltonian
Description
 If  this  variable  is  set  to  "yes",  then the ions that are outside the
 simulation  box  do  not feel any external force (and therefore progress at
 constant  velocity),  and  do not originate any force on other ions, or any
 potential on the electronic system. 

 This  feature  is  only  available  for  finite  systems;  if the system is
 periodic in any dimension, this variable cannot be set to "yes". 
END

Variable LRMaximumIter
Type integer
Default 200
Section Linear Response::SCF in LR calculations
Description
 The maximum number of SCF iterations to calculate response. 
END

Variable LRConvAbsDens
Type float
Default 1e-5
Section Linear Response::SCF in LR calculations
Description
 The  tolerance in the variation of the density, to determine if the SCF for
 linear response is converged. 
END

Variable LRTolScheme
Type integer
Default tol_adaptive
Section Linear Response::SCF in LR calculations
Description
 The  scheme  used  to  adjust  the  tolerance  of the solver during the SCF
 iteration.  For  kdotp  and  magnetic  em_resp  modes,  or  whenever
 HamiltonianVariation  =  V_ext_only,  the  scheme is set to fixed, and this
 variable is ignored. 
Option tol_fixed 0
 The  solver  tolerance  is  fixed  for  all  the  iterations; this improves
 convergence but increases the computational cost 
Option tol_adaptive 1
 The  tolerance  is  increased  according to the level of convergence of the
 SCF. 
Option tol_linear 2
 The tolerance decreases linearly for the first LRTolIterWindow iterations. 
Option tol_exp 3
 The  tolerance  decreases  exponentially  for  the  first  LRTolIterWindow
 iterations. 
END

Variable LRTolInitTol
Type float
Default 1e-2
Section Linear Response::Solver
Description
 This  is  the  tolerance to determine that the linear solver has converged,
 for the first SCF iteration. Ignored if LRTolScheme = fixed. 
END

Variable LRTolFinalTol
Type float
Default 1e-6
Section Linear Response::Solver
Description
 This is the tolerance to determine that the linear solver has converged. 
END

Variable LRTolAdaptiveFactor
Type float
Default 0.1
Section Linear Response::SCF in LR calculations
Description
 This  factor  controls  how  much  the  tolerance  is  decreased during the
 self-consistency  process.  Smaller values mean that tolerance is decreased
 faster. 
END

Variable LRTolIterWindow
Type float
Default 10
Section Linear Response::SCF in LR calculations
Description
 Number of iterations necessary to reach the final tolerance 
END

Variable CalculateSelfInducedMagneticField
Type logical
Default no
Section Hamiltonian
Description
 The  existence  of  an  electronic  current  implies  the  creation  of  a
 self-induced magnetic field, which may in turn back-react on the system. Of
 course,  a fully consistent treatment of this kind of effect should be done
 in  QED theory, but we will attempt a first approximation to the problem by
 considering  the  lowest-order  relativistic  terms plugged into the normal
 Hamiltonian  equations  (spin-other-orbit  coupling  terms,  etc.). For the
 moment  being,  none  of  this  is  done,  but  a  first  step  is taken by
 calculating  the  induced magnetic field of a system that has a current, by
 considering the magnetostatic approximation and Biot-Savart law: 

  \nabla^2 \vec{A} + 4\pi\alpha \vec{J} = 0 

  \vec{B} = \vec{\nabla} \times \vec{A} 

 If  CalculateSelfInducedMagneticField  is  set  to  yes,  this _B_ field is
 calculated at the end of a gs calculation (nothing is done -- yet -- in the
 td  case)  and  printed  out, if the Output variable contains the potential
 keyword (the prefix of the output files is Bind). 
END

Variable AbsorbingBoundaries
Type integer
Default not_absorbing
Section Time-Dependent::Absorbing Boundaries
Description
 To improve the quality of the spectra by avoiding the formation of standing
 density waves, one can make the boundaries of the simulation box absorbing.
 
Option not_absorbing 0
 No absorbing boundaries. 
Option sin2 1
 A \sin^2 imaginary potential is added at the boundaries. 
Option mask 2
 A mask is applied to the wavefunctions at the boundaries. 
Option exact 3
 NOT  WORKING  YET! An exactly absorbing scheme is used for open boundaries.
 This  feature  comes  from  transport  calculation  and  assumes  that  on
 OpenBoundariesNLeads  sides  there is a lead connected. No outgoing density
 is  reflected within the leads, but some minor reflection will occur on the
 corners  of the box. This is due to the setup of semi-infinite finite width
 leads  connected  to  the  sides.  Warning: This scheme works only with the
 special Cranck-Nicholson propagator and has quadratic scaling with time. It
 may be tuned with the parameter OpenBoundariesMaxMemCoeffs. 
END

Variable ParticleMass
Type float
Default 1.0
Section Hamiltonian
Description
 It  is  possible  to make calculations for a particle with a mass different
 from  one (atomic unit of mass, or mass of the electron). This is useful to
 describe non-electronic systems, or for esoteric purposes. 
END

Variable MassScaling
Type block
Section Hamiltonian
Description
 Scaling  factor  for  anisotropic  masses  (different  masses  along  each
 geometric direction). 

 %MassScaling 
   1.0 | 1800.0 | 1800.0 
 % 

 would  fix  the  mass  of  the  particles  to be 1800 along the _y_ and _z_
 directions.  This  can be useful, _e.g._, to simulate 3 particles in 1D, in
 this case an electron and 2 protons. 

END

Variable StatesPack
Type logical
Default yes
Section Execution::Optimization
Description
 If  set  to  yes (the default), Octopus will 'pack' the wave-functions when
 operating  with  them.  This  involves  some  additional  copying but makes
 operations more efficient. 
END

Variable ABWidth
Type float
Default 0.4 a.u.
Section Time-Dependent::Absorbing Boundaries
Description
 Width of the region used to apply the absorbing boundaries. 
END

Variable ABHeight
Type float
Default -0.2 a.u.
Section Time-Dependent::Absorbing Boundaries
Description
 When  AbsorbingBoundaries  =  sin2,  this  is  the  height of the imaginary
 potential. 
END

Variable GaugeVectorField
Type block
Section Hamiltonian
Description
 The  gauge  vector  field is used to include a uniform (but time-dependent)
 external  electric  field in a time-dependent run for a periodic system. An
 optional  second row specifies the initial value for the time derivative of
 the gauge field (which is set to zero by default). By default this field is
 not included. 
END

Variable BornChargeSumRuleCorrection
Type logical
Default true
Section Linear Response::Polarizabilities
Description
 Enforce  the  acoustic  sum  rule  by  distributing  the excess sum of Born
 charges  equally among the atoms. Sum rule: sum(iatom) Z*(iatom,idir,idir2)
 =  Z_tot  delta(idir1,  idir2).  Violation of the sum rule may be caused by
 inadequate spacing, box size, or _k_-point sampling. 
END

Variable GuessMagnetDensity
Type integer
Default ferromagnetic
Section SCF
Description
 The  guess  density  for  the  SCF  cycle is just the sum of all the atomic
 densities.  When  performing  spin-polarized  or  non-collinear-spin
 calculations this option sets the guess magnetization density. 

 For  anti-ferromagnetic  configurations,  the user_defined option should be
 used. 

 Note  that  if the paramagnetic option is used, the final ground state will
 also be paramagnetic, but the same is not true for the other options. 
Option paramagnetic 1
 Magnetization density is zero. 
Option ferromagnetic 2
 Magnetization density is the sum of the atomic magnetization densities. 
Option random 3
 Each atomic magnetization density is randomly rotated. 
Option user_defined 77
 The  atomic  magnetization  densities are rotated so that the magnetization
 vector  has  the  same  direction as a vector provided by the user. In this
 case, the AtomsMagnetDirection block has to be set. 
END

Variable AtomsMagnetDirection
Type block
Section Hamiltonian
Description
 This option is only used when GuessMagnetDensity is set to user_defined. It
 provides  a  direction  for  the  magnetization  vector  of  each atom when
 building  the  guess  density. In order to do that, the user should specify
 the  coordinates  of a vector that has the desired direction and norm. Note
 that  it  is  necessary  to maintain the ordering in which the species were
 defined in the coordinates specifications. 

 For  spin-polarized  calculations,  the  vectors  should  have  only  one
 component;  for  non-collinear-spin  calculations,  they  should have three
 components. 
END

